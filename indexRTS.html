<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Forest RTS - Map Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
            touch-action: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 25, 15, 0.85);
            border: 2px solid #4a7c3f;
            border-radius: 8px;
            padding: 15px;
            color: #a8d5a2;
            font-size: 12px;
            line-height: 1.6;
            pointer-events: auto;
            max-width: 280px;
        }

        #controls-help h3 {
            color: #7ddf64;
            margin-bottom: 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #controls-help .key {
            display: inline-block;
            background: #2d4a2d;
            border: 1px solid #5a8a5a;
            border-radius: 3px;
            padding: 2px 6px;
            margin: 0 2px;
            font-weight: bold;
            color: #c8f0c8;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 180px;
            height: 90px;
            background: rgba(15, 25, 15, 0.9);
            border: 2px solid #4a7c3f;
            border-radius: 4px;
            pointer-events: auto;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            border-radius: 2px;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(15, 25, 15, 0.85);
            border: 2px solid #4a7c3f;
            border-radius: 8px;
            padding: 15px;
            color: #a8d5a2;
            font-size: 13px;
            pointer-events: auto;
        }

        #info-panel h2 {
            color: #7ddf64;
            font-size: 16px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(74, 124, 63, 0.3);
        }

        .stat-label {
            color: #7a9a7a;
        }

        .stat-value {
            color: #c8f0c8;
            font-weight: bold;
        }

        .tree-legend {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid #4a7c3f;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .legend-color.normal { background: linear-gradient(135deg, #2d5a1e, #4a8c3a); }
        .legend-color.high-yield { background: linear-gradient(135deg, #1a3a12, #2d5a1e); }
        .legend-color.energy { background: linear-gradient(135deg, #6b2d8a, #9b4dca); }
        .legend-color.clearing { background: linear-gradient(135deg, #5a4a2a, #7a6a4a); }

        #mobile-controls {
            position: absolute;
            bottom: 100px;
            right: 20px;
            display: none;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: grid;
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
                gap: 5px;
            }

            #controls-help {
                display: none;
            }
        }

        .mobile-btn {
            width: 50px;
            height: 50px;
            background: rgba(15, 25, 15, 0.85);
            border: 2px solid #4a7c3f;
            border-radius: 8px;
            color: #7ddf64;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        .mobile-btn:active {
            background: #4a7c3f;
            color: #1a1a2e;
        }

        .mobile-btn.up { grid-column: 2; grid-row: 1; }
        .mobile-btn.down { grid-column: 2; grid-row: 3; }
        .mobile-btn.left { grid-column: 1; grid-row: 2; }
        .mobile-btn.right { grid-column: 3; grid-row: 2; }
        .mobile-btn.zoomin { grid-column: 1; grid-row: 1; }
        .mobile-btn.zoomout { grid-column: 3; grid-row: 1; }
        .mobile-btn.rotleft { grid-column: 1; grid-row: 3; }
        .mobile-btn.rotright { grid-column: 3; grid-row: 3; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="info-panel" style="display: none;">
                <h2>ðŸŒ² Forest Map</h2>
                <div class="stat-row">
                    <span class="stat-label">Grid Size:</span>
                    <span class="stat-value">200 Ã— 400</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Trees:</span>
                    <span class="stat-value" id="tree-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Camera Pos:</span>
                    <span class="stat-value" id="camera-pos">0, 0</span>
                </div>
                <div class="tree-legend">
                    <div class="legend-item">
                        <div class="legend-color normal"></div>
                        <span>Normal Tree</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color high-yield"></div>
                        <span>High-Yield Tree</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color energy"></div>
                        <span>Energy Tree</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color clearing"></div>
                        <span>Base Clearing</span>
                    </div>
                </div>
            </div>

            <canvas id="minimap-canvas"></canvas>
            <div id="minimap">
                <canvas id="minimap-canvas"></canvas>
            </div>

            <div id="debug-panel" style="
            display: none;
            position: absolute;
            bottom: 200px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 10px;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 9999;
            pointer-events: auto;
            border: 1px solid #0f0;
        "></div>

            <div id="controls-help">
                <h3>ðŸŽ® Controls</h3>
                <div><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> or <span class="key">Arrows</span> â€” Pan camera</div>
                <div><span class="key">Q</span><span class="key">E</span> â€” Rotate camera</div>
                <div><span class="key">R</span><span class="key">F</span> â€” Zoom in/out</div>
                <div><span class="key">Space</span> â€” Toggle top-down view</div>
                <div><span class="key">1</span><span class="key">2</span> â€” Jump to Player/Enemy base</div>
                <div style="margin-top: 8px; color: #7ddf64;">Click units to select & command</div>
            </div>

            <div id="mobile-controls">
                <div class="mobile-btn zoomin" data-action="zoomin">+</div>
                <div class="mobile-btn up" data-action="up">â–²</div>
                <div class="mobile-btn zoomout" data-action="zoomout">âˆ’</div>
                <div class="mobile-btn left" data-action="left">â—„</div>
                <div class="mobile-btn down" data-action="down">â–¼</div>
                <div class="mobile-btn right" data-action="right">â–º</div>
                <div class="mobile-btn rotleft" data-action="rotleft">â†º</div>
                <div class="mobile-btn rotright" data-action="rotright">â†»</div>
            </div>
        </div>
    </div>

    <script>
        // Pre-Three.js check
        document.getElementById('debug-panel').innerHTML = 'Waiting for THREE.js...<br>';
        
        // Timeout check
        setTimeout(function() {
            var panel = document.getElementById('debug-panel');
            if (typeof THREE === 'undefined') {
                panel.innerHTML += '<span style="color:orange">THREE.js taking too long, trying backup CDN...</span><br>';
                var backup = document.createElement('script');
                backup.src = 'https://unpkg.com/three@0.128.0/build/three.min.js';
                backup.onload = function() {
                    panel.innerHTML += 'Backup CDN loaded!<br>';
                };
                backup.onerror = function() {
                    panel.innerHTML += '<span style="color:red">Backup CDN also failed!</span><br>';
                };
                document.head.appendChild(backup);
            }
        }, 3000);
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" 
            onload="document.getElementById('debug-panel').innerHTML += 'THREE.js loaded from primary CDN<br>'"
            onerror="document.getElementById('debug-panel').innerHTML += '<span style=color:red>PRIMARY CDN FAILED</span><br>'"></script>
    <script>
        // GLOBAL ERROR HANDLER
        window.onerror = function(msg, url, line, col, error) {
            var panel = document.getElementById('debug-panel');
            if (panel) {
                panel.innerHTML += '<span style="color:red">ERROR: ' + msg + ' at line ' + line + '</span><br>';
            }
            console.error('Global error:', msg, url, line);
            return false;
        };
        
        // IMMEDIATE DEBUG - First thing that runs
        (function() {
            var panel = document.getElementById('debug-panel');
            if (panel) panel.innerHTML = 'JS STARTED<br>';
        })();
        
        // Debug logging function
        function debug(msg) {
            console.log(msg);
            try {
                var panel = document.getElementById('debug-panel');
                if (panel) {
                    panel.innerHTML += msg + '<br>';
                    panel.scrollTop = panel.scrollHeight;
                }
            } catch(e) {
                console.log('Debug panel error:', e);
            }
        }
        
        debug('Debug function defined');
        debug('THREE exists: ' + (typeof THREE !== 'undefined'));
        
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            GRID_WIDTH: 200,
            GRID_HEIGHT: 400,
            CELL_SIZE: 1,
            
            // Clearing settings
            CLEARING_RADIUS: 25,
            CLEARING_PADDING: 30,
            
            // Tree distribution
            TREE_DENSITY: 0.7,
            HIGH_YIELD_EDGE_DISTANCE: 30,
            HIGH_YIELD_PROBABILITY: 0.4,
            ENERGY_CENTER_CLUSTER_RADIUS: 60,
            ENERGY_CENTER_PROBABILITY: 0.15,
            ENERGY_SCATTER_PROBABILITY: 0.02,
            
            // Visual settings
            TREE_SCALE_MIN: 0.8,
            TREE_SCALE_MAX: 1.4,
            
            // Camera
            CAMERA_SPEED: 0.5,
            ZOOM_SPEED: 2,
            ROTATE_SPEED: 0.03
        };
        
        debug('CONFIG defined');

        // ============================================
        // GAME STATE
        // ============================================
        const gameState = {
            grid: [],
            trees: [],
            buildings: [],
            units: [],
            playerBuildingSites: [],
            enemyBuildingSites: [],
            selectedSite: null,
            selectedBuilding: null,
            selectedUnit: null,
            resources: {
                wood: 5000,
                energy: 3000
            },
            camera: {
                target: { x: CONFIG.GRID_WIDTH / 2, z: CONFIG.GRID_HEIGHT / 2 },
                distance: 80,
                angle: 0,
                pitch: Math.PI / 4,
                isTopDown: false
            },
            input: {
                keys: {},
                mobileActions: {}
            }
        };
        
        debug('gameState defined');
        
        // Raycaster for click detection - created lazily
        let raycaster = null;
        let mouse = null;
        
        function ensureRaycaster() {
            if (!raycaster) {
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
            }
        }
        
        debug('Raycaster setup defined');

        // Cell types
        const CELL = {
            EMPTY: 0,
            TREE_NORMAL: 1,
            TREE_HIGH_YIELD: 2,
            TREE_ENERGY: 3,
            CLEARING_PLAYER: 4,
            CLEARING_ENEMY: 5
        };
        
        debug('CELL types defined');
        debug('All top-level definitions complete');

        // ============================================
        // THREE.JS SETUP
        // ============================================
        let scene, camera, renderer;
        let treeGeometry, treeMaterials;

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2a1a);
            scene.fog = new THREE.Fog(0x1a2a1a, 50, 200);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Raycaster for click detection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffcc, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Ground plane
            createGround();

            // Initialize tree materials
            createTreeMaterials();

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(
                CONFIG.GRID_WIDTH * CONFIG.CELL_SIZE,
                CONFIG.GRID_HEIGHT * CONFIG.CELL_SIZE
            );
            
            // Create a canvas texture for the ground
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Base color
            ctx.fillStyle = '#3d5a3d';
            ctx.fillRect(0, 0, 512, 1024);
            
            // Add noise/variation
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 1024;
                const shade = Math.random() * 30 - 15;
                ctx.fillStyle = `rgb(${61 + shade}, ${90 + shade}, ${61 + shade})`;
                ctx.fillRect(x, y, 2, 2);
            }
            
            const groundTexture = new THREE.CanvasTexture(canvas);
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(4, 8);
            
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                map: groundTexture
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(
                CONFIG.GRID_WIDTH * CONFIG.CELL_SIZE / 2,
                0,
                CONFIG.GRID_HEIGHT * CONFIG.CELL_SIZE / 2
            );
            scene.add(ground);
        }

        function createTreeMaterials() {
            // Create pixel-art style tree textures
            treeMaterials = {
                normal: createNormalTreeMaterial(),
                highYield: createHighYieldTreeMaterial(),
                energy: createEnergyTreeMaterial()
            };
        }

        function createNormalTreeMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 96;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, 64, 96);
            
            // Trunk
            ctx.fillStyle = '#1a3a12';
            ctx.fillRect(26, 60, 12, 36);
            
            // Tree outline (darker)
            ctx.fillStyle = '#2d5a1e';
            ctx.beginPath();
            ctx.moveTo(32, 4);
            ctx.lineTo(8, 64);
            ctx.lineTo(56, 64);
            ctx.closePath();
            ctx.fill();
            
            // Tree inner (lighter)
            ctx.fillStyle = '#4a8c3a';
            ctx.beginPath();
            ctx.moveTo(32, 12);
            ctx.lineTo(16, 56);
            ctx.lineTo(48, 56);
            ctx.closePath();
            ctx.fill();
            
            // Pixel details
            ctx.fillStyle = '#2d5a1e';
            for (let i = 0; i < 8; i++) {
                const x = 20 + Math.random() * 24;
                const y = 20 + Math.random() * 30;
                ctx.fillRect(x, y, 4, 4);
            }
            
            // Border
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(32, 4);
            ctx.lineTo(8, 64);
            ctx.lineTo(56, 64);
            ctx.closePath();
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            
            return new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
        }

        function createHighYieldTreeMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 96;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, 64, 96);
            
            // Thicker trunk
            ctx.fillStyle = '#2a1a0a';
            ctx.fillRect(22, 55, 20, 41);
            
            // Darker, denser foliage - multiple layers
            ctx.fillStyle = '#1a3a12';
            ctx.beginPath();
            ctx.moveTo(32, 0);
            ctx.lineTo(2, 60);
            ctx.lineTo(62, 60);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#2d4a1e';
            ctx.beginPath();
            ctx.moveTo(32, 8);
            ctx.lineTo(10, 55);
            ctx.lineTo(54, 55);
            ctx.closePath();
            ctx.fill();
            
            // Inner highlight
            ctx.fillStyle = '#3a6a2a';
            ctx.beginPath();
            ctx.moveTo(32, 16);
            ctx.lineTo(18, 48);
            ctx.lineTo(46, 48);
            ctx.closePath();
            ctx.fill();
            
            // Dense pixel details
            ctx.fillStyle = '#1a3a12';
            for (let i = 0; i < 15; i++) {
                const x = 16 + Math.random() * 32;
                const y = 16 + Math.random() * 35;
                ctx.fillRect(x, y, 4, 4);
            }
            
            // Border
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(32, 0);
            ctx.lineTo(2, 60);
            ctx.lineTo(62, 60);
            ctx.closePath();
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            
            return new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
        }

        function createEnergyTreeMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 96;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, 64, 96);
            
            // Crystalline trunk
            ctx.fillStyle = '#4a2a6a';
            ctx.fillRect(26, 60, 12, 36);
            
            // Glowing purple foliage
            ctx.fillStyle = '#6b2d8a';
            ctx.beginPath();
            ctx.moveTo(32, 4);
            ctx.lineTo(8, 64);
            ctx.lineTo(56, 64);
            ctx.closePath();
            ctx.fill();
            
            // Inner glow
            ctx.fillStyle = '#9b4dca';
            ctx.beginPath();
            ctx.moveTo(32, 14);
            ctx.lineTo(16, 56);
            ctx.lineTo(48, 56);
            ctx.closePath();
            ctx.fill();
            
            // Bright core
            ctx.fillStyle = '#bb6dea';
            ctx.beginPath();
            ctx.moveTo(32, 24);
            ctx.lineTo(22, 48);
            ctx.lineTo(42, 48);
            ctx.closePath();
            ctx.fill();
            
            // Energy sparkles
            ctx.fillStyle = '#ddaaff';
            for (let i = 0; i < 6; i++) {
                const x = 18 + Math.random() * 28;
                const y = 18 + Math.random() * 32;
                ctx.fillRect(x, y, 3, 3);
            }
            
            // Border
            ctx.strokeStyle = '#3a1a5a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(32, 4);
            ctx.lineTo(8, 64);
            ctx.lineTo(56, 64);
            ctx.closePath();
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            
            return new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // MAP GENERATION
        // ============================================
        function generateMap() {
            // Initialize grid
            for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                gameState.grid[x] = [];
                for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
                    gameState.grid[x][z] = CELL.EMPTY;
                }
            }

            // Create player clearing (bottom)
            const playerCenterX = CONFIG.GRID_WIDTH / 2;
            const playerCenterZ = CONFIG.CLEARING_PADDING;
            createClearing(playerCenterX, playerCenterZ, CELL.CLEARING_PLAYER, true);

            // Create enemy clearing (top)
            const enemyCenterX = CONFIG.GRID_WIDTH / 2;
            const enemyCenterZ = CONFIG.GRID_HEIGHT - CONFIG.CLEARING_PADDING;
            createClearing(enemyCenterX, enemyCenterZ, CELL.CLEARING_ENEMY, false);

            // Populate trees
            for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
                    if (gameState.grid[x][z] !== CELL.EMPTY) continue;
                    
                    if (Math.random() > CONFIG.TREE_DENSITY) continue;
                    
                    // Determine tree type
                    const treeType = determineTreeType(x, z);
                    gameState.grid[x][z] = treeType;
                    createTree(x, z, treeType);
                }
            }

            // Update tree count
            document.getElementById('tree-count').textContent = gameState.trees.length;
        }

        function createClearing(centerX, centerZ, cellType, isPlayer) {
            const radius = CONFIG.CLEARING_RADIUS;
            
            // Mark clearing cells
            for (let x = Math.floor(centerX - radius); x <= Math.ceil(centerX + radius); x++) {
                for (let z = Math.floor(centerZ - radius); z <= Math.ceil(centerZ + radius); z++) {
                    if (x < 0 || x >= CONFIG.GRID_WIDTH || z < 0 || z >= CONFIG.GRID_HEIGHT) continue;
                    
                    const dist = Math.sqrt((x - centerX) ** 2 + (z - centerZ) ** 2);
                    if (dist <= radius) {
                        gameState.grid[x][z] = cellType;
                    }
                }
            }

            // Create visual clearing indicator (subtle ground tint)
            const clearingGeometry = new THREE.CircleGeometry(radius, 32);
            const clearingMaterial = new THREE.MeshBasicMaterial({
                color: isPlayer ? 0x4a6a4a : 0x6a4a4a,
                transparent: true,
                opacity: 0.3
            });
            const clearing = new THREE.Mesh(clearingGeometry, clearingMaterial);
            clearing.rotation.x = -Math.PI / 2;
            clearing.position.set(centerX, 0.01, centerZ);
            scene.add(clearing);

            // Create building sites (10 sites in a clock pattern)
            createBuildingSites(centerX, centerZ, isPlayer);
        }

        function createBuildingSites(centerX, centerZ, isPlayer) {
            const siteRadius = 15; // Distance from center
            const numSites = 10;
            
            for (let i = 0; i < numSites; i++) {
                // Arrange in a circle like clock numbers
                const angle = (i / numSites) * Math.PI * 2 - Math.PI / 2; // Start from top
                const siteX = centerX + Math.cos(angle) * siteRadius;
                const siteZ = centerZ + Math.sin(angle) * siteRadius;
                
                // Create site marker
                const siteGeometry = new THREE.PlaneGeometry(6, 6);
                const siteMaterial = new THREE.MeshBasicMaterial({
                    color: isPlayer ? 0x5a8a5a : 0x8a5a5a,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const site = new THREE.Mesh(siteGeometry, siteMaterial);
                site.rotation.x = -Math.PI / 2;
                site.position.set(siteX, 0.02, siteZ);
                site.userData.isPlayer = isPlayer;
                site.userData.siteIndex = i;
                scene.add(site);

                if (isPlayer) {
                    gameState.playerBuildingSites.push(site);
                } else {
                    gameState.enemyBuildingSites.push(site);
                }
            }
        }

        function determineTreeType(x, z) {
            const centerX = CONFIG.GRID_WIDTH / 2;
            const centerZ = CONFIG.GRID_HEIGHT / 2;
            
            // Distance from map center
            const distFromCenter = Math.sqrt((x - centerX) ** 2 + (z - centerZ) ** 2);
            
            // Energy trees in center cluster
            if (distFromCenter <= CONFIG.ENERGY_CENTER_CLUSTER_RADIUS) {
                if (Math.random() < CONFIG.ENERGY_CENTER_PROBABILITY) {
                    return CELL.TREE_ENERGY;
                }
            } else if (Math.random() < CONFIG.ENERGY_SCATTER_PROBABILITY) {
                return CELL.TREE_ENERGY;
            }
            
            // High-yield trees near edges
            const distFromEdgeX = Math.min(x, CONFIG.GRID_WIDTH - x);
            const distFromEdgeZ = Math.min(z, CONFIG.GRID_HEIGHT - z);
            const distFromEdge = Math.min(distFromEdgeX, distFromEdgeZ);
            
            if (distFromEdge <= CONFIG.HIGH_YIELD_EDGE_DISTANCE) {
                if (Math.random() < CONFIG.HIGH_YIELD_PROBABILITY) {
                    return CELL.TREE_HIGH_YIELD;
                }
            }
            
            return CELL.TREE_NORMAL;
        }

        function createTree(x, z, treeType) {
            let material;
            switch (treeType) {
                case CELL.TREE_HIGH_YIELD:
                    material = treeMaterials.highYield.clone();
                    break;
                case CELL.TREE_ENERGY:
                    material = treeMaterials.energy.clone();
                    break;
                default:
                    material = treeMaterials.normal.clone();
            }

            const sprite = new THREE.Sprite(material);
            
            // Random scale variation
            const scale = CONFIG.TREE_SCALE_MIN + Math.random() * (CONFIG.TREE_SCALE_MAX - CONFIG.TREE_SCALE_MIN);
            sprite.scale.set(3 * scale, 4.5 * scale, 1);
            
            // Position with slight randomness
            const offsetX = (Math.random() - 0.5) * 0.5;
            const offsetZ = (Math.random() - 0.5) * 0.5;
            sprite.position.set(
                x + 0.5 + offsetX,
                2.25 * scale,
                z + 0.5 + offsetZ
            );
            
            // Store grid position for harvesting
            sprite.userData.gridX = x;
            sprite.userData.gridZ = z;
            sprite.userData.treeType = treeType;

            scene.add(sprite);
            gameState.trees.push(sprite);
        }

        // ============================================
        // CAMERA CONTROLS
        // ============================================
        function updateCamera() {
            const input = gameState.input;
            const cam = gameState.camera;

            // Pan
            let moveX = 0, moveZ = 0;
            if (input.keys['KeyW'] || input.keys['ArrowUp'] || input.mobileActions.up) moveZ -= 1;
            if (input.keys['KeyS'] || input.keys['ArrowDown'] || input.mobileActions.down) moveZ += 1;
            if (input.keys['KeyA'] || input.keys['ArrowLeft'] || input.mobileActions.left) moveX -= 1;
            if (input.keys['KeyD'] || input.keys['ArrowRight'] || input.mobileActions.right) moveX += 1;

            // Apply rotation to movement
            const cos = Math.cos(cam.angle);
            const sin = Math.sin(cam.angle);
            const worldMoveX = moveX * cos - moveZ * sin;
            const worldMoveZ = moveX * sin + moveZ * cos;

            cam.target.x += worldMoveX * CONFIG.CAMERA_SPEED;
            cam.target.z += worldMoveZ * CONFIG.CAMERA_SPEED;

            // Clamp to map bounds
            cam.target.x = Math.max(0, Math.min(CONFIG.GRID_WIDTH, cam.target.x));
            cam.target.z = Math.max(0, Math.min(CONFIG.GRID_HEIGHT, cam.target.z));

            // Rotate
            if (input.keys['KeyQ'] || input.mobileActions.rotleft) cam.angle += CONFIG.ROTATE_SPEED;
            if (input.keys['KeyE'] || input.mobileActions.rotright) cam.angle -= CONFIG.ROTATE_SPEED;

            // Zoom
            if (input.keys['KeyR'] || input.mobileActions.zoomin) cam.distance -= CONFIG.ZOOM_SPEED;
            if (input.keys['KeyF'] || input.mobileActions.zoomout) cam.distance += CONFIG.ZOOM_SPEED;
            cam.distance = Math.max(20, Math.min(200, cam.distance));

            // Toggle top-down
            if (input.keys['Space'] && !input.spacePressed) {
                cam.isTopDown = !cam.isTopDown;
                input.spacePressed = true;
            } else if (!input.keys['Space']) {
                input.spacePressed = false;
            }

            // Quick jump to bases
            if (input.keys['Digit1'] && !input.digit1Pressed) {
                jumpToLocation(CONFIG.GRID_WIDTH / 2, CONFIG.CLEARING_PADDING);
                input.digit1Pressed = true;
            } else if (!input.keys['Digit1']) {
                input.digit1Pressed = false;
            }

            if (input.keys['Digit2'] && !input.digit2Pressed) {
                jumpToLocation(CONFIG.GRID_WIDTH / 2, CONFIG.GRID_HEIGHT - CONFIG.CLEARING_PADDING);
                input.digit2Pressed = true;
            } else if (!input.keys['Digit2']) {
                input.digit2Pressed = false;
            }

            // Calculate camera position
            const targetPitch = cam.isTopDown ? Math.PI / 2 - 0.01 : Math.PI / 4;
            cam.pitch += (targetPitch - cam.pitch) * 0.1;

            const height = Math.sin(cam.pitch) * cam.distance;
            const horizontalDist = Math.cos(cam.pitch) * cam.distance;

            camera.position.set(
                cam.target.x + Math.sin(cam.angle) * horizontalDist,
                height,
                cam.target.z + Math.cos(cam.angle) * horizontalDist
            );
            camera.lookAt(cam.target.x, 0, cam.target.z);

            // Update debug info
            document.getElementById('camera-pos').textContent = 
                `${Math.floor(cam.target.x)}, ${Math.floor(cam.target.z)}`;
        }

        function jumpToLocation(x, z) {
            gameState.camera.target.x = x;
            gameState.camera.target.z = z;
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        function initInput() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                gameState.input.keys[e.code] = true;
            });
            window.addEventListener('keyup', (e) => {
                gameState.input.keys[e.code] = false;
            });

            // Mobile controls
            document.querySelectorAll('.mobile-btn').forEach(btn => {
                const action = btn.dataset.action;
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    gameState.input.mobileActions[action] = true;
                });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    gameState.input.mobileActions[action] = false;
                });
            });

            // Touch controls for camera pan
            let touchStart = null;
            let lastTouchDistance = null;

            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    lastTouchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && touchStart) {
                    const dx = e.touches[0].clientX - touchStart.x;
                    const dy = e.touches[0].clientY - touchStart.y;
                    
                    // Only pan if moved significantly (not a tap)
                    if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                        gameState.camera.target.x -= dx * 0.1;
                        gameState.camera.target.z -= dy * 0.1;
                        touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                    
                    // Update corridor preview while in cut mode
                    updatePreviewFromTouch(e.touches[0].clientX, e.touches[0].clientY);
                    
                } else if (e.touches.length === 2 && lastTouchDistance) {
                    const newDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const delta = lastTouchDistance - newDistance;
                    gameState.camera.distance += delta * 0.2;
                    gameState.camera.distance = Math.max(20, Math.min(200, gameState.camera.distance));
                    lastTouchDistance = newDistance;
                }
            });

            renderer.domElement.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 1 && touchStart) {
                    const touch = e.changedTouches[0];
                    const dx = touch.clientX - touchStart.x;
                    const dy = touch.clientY - touchStart.y;
                    
                    // If minimal movement, it was a tap
                    if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                        onCanvasClick({ clientX: touch.clientX, clientY: touch.clientY });
                    }
                }
                touchStart = null;
            });

            // Mouse wheel zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                gameState.camera.distance += e.deltaY * 0.1;
                gameState.camera.distance = Math.max(20, Math.min(200, gameState.camera.distance));
            });
            
            // Click detection for building sites and units
            renderer.domElement.addEventListener('click', onCanvasClick);
            
            // Mouse move for corridor preview
            renderer.domElement.addEventListener('mousemove', onCanvasMouseMove);
        }

        // ============================================
        // CORRIDOR PREVIEW ON MOUSE MOVE
        // ============================================
        function onCanvasMouseMove(event) {
            if (!window.GameUnits) return;
            
            const commandMode = GameUnits.getCommandMode();
            if (commandMode !== 'cutPath' && commandMode !== 'cutLane') {
                return;
            }
            
            ensureRaycaster();
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectPoint);
            
            if (intersectPoint) {
                GameUnits.updateCorridorPreview(intersectPoint.x, intersectPoint.z);
            }
        }
        
        function updatePreviewFromTouch(clientX, clientY) {
            if (!window.GameUnits) return;
            
            const commandMode = GameUnits.getCommandMode();
            if (commandMode !== 'cutPath' && commandMode !== 'cutLane') {
                return;
            }
            
            ensureRaycaster();
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectPoint);
            
            if (intersectPoint) {
                GameUnits.updateCorridorPreview(intersectPoint.x, intersectPoint.z);
            }
        }

        // ============================================
        // CLICK DETECTION
        // ============================================
        function onCanvasClick(event) {
            ensureRaycaster();
            
            // Calculate mouse position
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check if we're in command mode
            if (window.GameUnits) {
                const commandMode = GameUnits.getCommandMode();
                
                if (commandMode === 'move' || commandMode === 'cutPath' || commandMode === 'cutLane') {
                    // Get ground intersection for command
                    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const intersectPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(groundPlane, intersectPoint);
                    
                    if (intersectPoint) {
                        const selectedUnits = GameUnits.getSelectedUnits();
                        if (selectedUnits && selectedUnits.length > 0) {
                            if (commandMode === 'move') {
                                // Use multi-select move command (handles formation)
                                GameUnits.commandMoveMultiple(selectedUnits, intersectPoint.x, intersectPoint.z);
                            } else if (commandMode === 'cutPath') {
                                // Cut path (2 wide)
                                GameUnits.commandCutCorridor(selectedUnits, intersectPoint.x, intersectPoint.z, 2);
                            } else if (commandMode === 'cutLane') {
                                // Cut lane (4 wide)
                                GameUnits.commandCutCorridor(selectedUnits, intersectPoint.x, intersectPoint.z, 4);
                            }
                            
                            GameUnits.setCommandMode(null);
                            if (window.GameUI) {
                                GameUI.hideCommandIndicator();
                                GameUI.showUnitMenu(selectedUnits);
                            }
                        }
                    }
                    return;
                }
            }
            
            // Check for unit selection first
            if (window.GameUnits && gameState.units.length > 0) {
                const unitSprites = gameState.units.map(u => u.sprite);
                const unitIntersects = raycaster.intersectObjects(unitSprites);
                
                if (unitIntersects.length > 0) {
                    const clickedSprite = unitIntersects[0].object;
                    const clickedUnit = gameState.units.find(u => u.sprite === clickedSprite);
                    
                    if (clickedUnit && clickedUnit.owner === 'player') {
                        GameUnits.selectUnit(clickedUnit);
                        return;
                    }
                }
            }
            
            // Check building sites
            const siteIntersects = raycaster.intersectObjects(gameState.playerBuildingSites);
            
            if (siteIntersects.length > 0) {
                const clickedSite = siteIntersects[0].object;
                
                // Deselect any unit first
                if (window.GameUnits) {
                    GameUnits.deselectAllUnits();
                }
                
                if (clickedSite.userData.building) {
                    // Site has a building - show building menu
                    gameState.selectedBuilding = clickedSite.userData.building;
                    gameState.selectedSite = null;
                    if (window.GameUI) {
                        GameUI.showBuildingMenu(clickedSite.userData.building);
                    }
                } else {
                    // Empty site - show build menu
                    gameState.selectedSite = clickedSite;
                    gameState.selectedBuilding = null;
                    if (window.GameUI) {
                        GameUI.showBuildMenu(clickedSite);
                    }
                }
                return;
            }
            
            // Clicked elsewhere - close menus and deselect
            gameState.selectedSite = null;
            gameState.selectedBuilding = null;
            
            if (window.GameUnits) {
                GameUnits.deselectAllUnits();
            }
            
            if (window.GameUI) {
                GameUI.hideMenus();
            }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);
            updateCamera();
            
            // Update units if module loaded
            if (window.GameUnits) {
                GameUnits.update();
            }
            
            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            debug('=== INIT START ===');
            
            try {
                debug('1. Calling initThree()...');
                initThree();
                debug('1. initThree() OK. scene:' + !!scene + ' cam:' + !!camera + ' rend:' + !!renderer);
            } catch(e) {
                debug('ERROR initThree: ' + e.message);
                return;
            }
            
            try {
                debug('2. Calling generateMap()...');
                generateMap();
                debug('2. generateMap() OK. Trees:' + gameState.trees.length);
            } catch(e) {
                debug('ERROR generateMap: ' + e.message);
                return;
            }
            
            try {
                debug('3. Calling initInput()...');
                initInput();
                debug('3. initInput() OK');
            } catch(e) {
                debug('ERROR initInput: ' + e.message);
                return;
            }
            
            // Expose globals for modules AFTER Three.js is initialized
            debug('4. Setting GameEngine globals...');
            window.GameEngine = {
                scene,
                camera,
                renderer,
                gameState,
                CONFIG,
                CELL,
                THREE
            };
            debug('4. GameEngine OK');
            
            // Start at player base
            debug('5. Jump to player base...');
            jumpToLocation(CONFIG.GRID_WIDTH / 2, CONFIG.CLEARING_PADDING);
            
            // Initialize modules after DOM ready
            try {
                debug('6. Init modules...');
                if (window.GameUI) {
                    debug('6a. GameUI.init()...');
                    GameUI.init();
                } else {
                    debug('6a. GameUI NOT FOUND');
                }
                if (window.GameBuildings) {
                    debug('6b. GameBuildings.init()...');
                    GameBuildings.init();
                } else {
                    debug('6b. GameBuildings NOT FOUND');
                }
                if (window.GameUnits) {
                    debug('6c. GameUnits.init()...');
                    GameUnits.init();
                } else {
                    debug('6c. GameUnits NOT FOUND');
                }
                debug('6. Modules done');
            } catch(e) {
                debug('ERROR modules: ' + e.message);
            }
            
            debug('7. Starting animate...');
            animate();
            debug('=== INIT COMPLETE ===');
        }

        // Wait for modules to load
        window.addEventListener('load', init);
        
        // Early check that script is running
        debug('Script loaded, waiting for window.load event...');
        debug('THREE.js available: ' + (typeof THREE !== 'undefined'));
    </script>
    <script src="js/buildings.js" onerror="debug('FAILED to load buildings.js')"></script>
    <script src="js/units.js" onerror="debug('FAILED to load units.js')"></script>
    <script src="js/ui.js" onerror="debug('FAILED to load ui.js')"></script>
</body>
</html>
