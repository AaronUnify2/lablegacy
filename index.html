<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth Legacy</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #healthBar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #8B4513;
            border-radius: 10px;
        }

        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #8B0000, #DC143C);
            border-radius: 8px;
            width: 100%;
            transition: width 0.3s ease;
        }

        #staminaBar {
            position: absolute;
            top: 50px;
            left: 20px;
            width: 150px;
            height: 15px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #4682B4;
            border-radius: 8px;
        }

        #staminaFill {
            height: 100%;
            background: linear-gradient(90deg, #4169E1, #87CEEB);
            border-radius: 6px;
            width: 100%;
            transition: width 0.2s ease;
        }

        #manaBar {
            position: absolute;
            top: 75px;
            left: 20px;
            width: 150px;
            height: 15px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #9370DB;
            border-radius: 8px;
        }

        #manaFill {
            height: 100%;
            background: linear-gradient(90deg, #4B0082, #9370DB);
            border-radius: 6px;
            width: 100%;
            transition: width 0.2s ease;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            pointer-events: none;
        }

        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255,255,255,0.9);
            border-radius: 50%;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            pointer-events: none;
        }

        /* Mobile Controls Styles */
        #mobile-controls {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 40%;
            z-index: 1000;
            pointer-events: none;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0;
        }

        #joystick {
            position: relative;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid rgba(100, 149, 237, 0.8);
            background-color: rgba(65, 105, 225, 0.3);
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(100, 149, 237, 0.8);
            margin-left: 20px;
        }

        #joystick-knob {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(65, 105, 225, 0.8);
            pointer-events: none;
        }

        #menu-button {
            width: 31px;
            height: 31px;
            border-radius: 50%;
            background-color: rgba(240, 240, 240, 0.8);
            border: 2px solid rgba(255, 255, 255, 1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
            font-family: Arial, sans-serif;
            font-weight: bold;
            font-size: 11px;
            user-select: none;
            pointer-events: auto;
            position: relative;
        }

        #action-buttons {
            position: relative;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 6px;
            pointer-events: auto;
            margin-right: 20px;
        }

        .control-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            font-weight: bold;
            user-select: none;
            font-size: 16px;
            transition: transform 0.1s ease;
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
            #instructions {
                display: none;
            }
        }

        /* Floor indicator */
        #floorIndicator {
            position: absolute;
            top: 100px;
            left: 20px;
            color: rgba(255,255,255,0.9);
            font-size: 18px;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div id="healthBar">
                <div id="healthFill"></div>
            </div>
            <div id="staminaBar">
                <div id="staminaFill"></div>
            </div>
            <div id="manaBar">
                <div id="manaFill"></div>
            </div>
            <div id="crosshair"></div>
            <div id="floorIndicator">Floor 1</div>
            <div id="instructions">
                WASD: Move | Mouse: Look | Shift: Dash | Space: Jump | E: Interact | Esc: Menu<br>
                <small>Mobile: Left stick to move, right stick to look, tap action buttons</small><br>
                <small>Testing: Menu button = +10 floors, E+Esc = +1 floor</small>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div id="joystick">
                <div id="joystick-knob"></div>
            </div>
            
            <div id="menu-button" class="control-button" data-action="menu">
                <div style="display: flex; flex-direction: column; gap: 2px;">
                    <div style="width: 12px; height: 2px; background-color: #333; border-radius: 1px;"></div>
                    <div style="width: 12px; height: 2px; background-color: #333; border-radius: 1px;"></div>
                    <div style="width: 12px; height: 2px; background-color: #333; border-radius: 1px;"></div>
                </div>
            </div>
            
            <div id="action-buttons">
                <div id="button-sword" class="control-button" data-action="attack" 
                     style="background-color: rgba(205, 133, 63, 0.8); border: 2px solid rgba(205, 133, 63, 1); 
                     box-shadow: 0 0 10px rgba(205, 133, 63, 0.8); grid-row: 1; grid-column: 1;">‚öîÔ∏è</div>
                
                <div id="button-staff" class="control-button" data-action="chargeAttack" 
                     style="background-color: rgba(186, 85, 211, 0.8); border: 2px solid rgba(186, 85, 211, 1); 
                     box-shadow: 0 0 10px rgba(186, 85, 211, 0.8); grid-row: 1; grid-column: 2;">üîÆ</div>
                
                <div id="button-jump" class="control-button" data-action="jump" 
                     style="background-color: rgba(60, 179, 113, 0.8); border: 2px solid rgba(60, 179, 113, 1); 
                     box-shadow: 0 0 10px rgba(60, 179, 113, 0.8); grid-row: 2; grid-column: 1;">‚¨ÜÔ∏è</div>
                
                <div id="button-dash" class="control-button" data-action="dash" 
                     style="background-color: rgba(255, 150, 50, 0.8); border: 2px solid rgba(255, 150, 50, 1); 
                     box-shadow: 0 0 10px rgba(255, 150, 50, 0.8); grid-row: 2; grid-column: 2;">üí®</div>
            </div>
        </div>
    </div>

    <!-- CRITICAL LOADING ORDER - GUARANTEED EXECUTION SEQUENCE -->
    <!-- 1. Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- 2. Input System -->
    <script src="src/core/input.js"></script>
    
    <!-- 3. Player System -->
    <script src="src/systems/player.js"></script>
    
    <!-- 4. Dungeon System -->
    <script>
// Unified Dungeon Generation System - Template + Corridor Carving Algorithm
// src/systems/dungeon.js

class DungeonSystem {
    constructor(scene, player) {
        console.log('Initializing Unified Dungeon System...');
        
        this.scene = scene;
        this.player = player;
        
        // Current dungeon state
        this.currentFloor = 1;
        this.currentDungeon = null;
        
        // Grid-based floor planning
        this.gridSize = 2; // 2 units per grid cell
        this.dungeonWidth = 120; // Total dungeon width in units
        this.dungeonDepth = 120; // Total dungeon depth in units
        this.gridWidth = Math.floor(this.dungeonWidth / this.gridSize);
        this.gridDepth = Math.floor(this.dungeonDepth / this.gridSize);
        
        // Room templates
        this.roomTemplates = {
            CENTER: { size: 13, type: 'center' },    // 26x26 units
            ORBITAL: { size: 10, type: 'orbital' },  // 20x20 units  
            CARDINAL: { size: 15, type: 'cardinal' } // 30x30 units
        };
        
        // Corridor width in grid cells
        this.corridorWidth = 2; // 4 units wide
        
        // Theme progression
        this.themes = {
            STONE: { floors: [1, 10], name: 'stone' },
            CRYSTAL: { floors: [11, 20], name: 'crystal' },
            RUINS: { floors: [21, 30], name: 'ruins' },
            CRYPT: { floors: [31, 40], name: 'crypt' },
            FOREST: { floors: [41, 50], name: 'forest' }
        };
        
        // Materials and lighting
        this.textureLoader = new THREE.TextureLoader();
        this.materials = new Map();
        this.lightSources = [];
        this.billboardSprites = [];
        
        // Room height
        this.ceilingHeight = 8;
        
        this.init();
    }
    
    init() {
        this.setupMaterials();
        this.setupBillboardSystem();
        console.log('Unified Dungeon System initialized');
    }
    
    setupMaterials() {
        this.createStoneMaterials();
        this.createCrystalMaterials();
        this.createRuinsMaterials();
        this.createCryptMaterials();
        this.createForestMaterials();
    }
    
    createStoneMaterials() {
        const stoneFloor = new THREE.MeshLambertMaterial({ color: 0x4a4a4a, transparent: true, opacity: 0.9 });
        const stoneWall = new THREE.MeshLambertMaterial({ color: 0x3a3a3a, transparent: true, opacity: 0.95 });
        const stoneCeiling = new THREE.MeshLambertMaterial({ color: 0x2a2a2a, transparent: true, opacity: 0.8 });
        
        this.materials.set('stone_floor', stoneFloor);
        this.materials.set('stone_wall', stoneWall);
        this.materials.set('stone_ceiling', stoneCeiling);
    }
    
    createCrystalMaterials() {
        const crystalFloor = new THREE.MeshPhongMaterial({ color: 0x4a4a6a, transparent: true, opacity: 0.9, shininess: 30 });
        const crystalWall = new THREE.MeshPhongMaterial({ color: 0x5a5a7a, transparent: true, opacity: 0.95, shininess: 50 });
        const crystalCeiling = new THREE.MeshPhongMaterial({ color: 0x3a3a5a, transparent: true, opacity: 0.8, shininess: 20 });
        
        this.materials.set('crystal_floor', crystalFloor);
        this.materials.set('crystal_wall', crystalWall);
        this.materials.set('crystal_ceiling', crystalCeiling);
    }
    
    createRuinsMaterials() {
        const ruinsFloor = new THREE.MeshLambertMaterial({ color: 0x6a4a6a, transparent: true, opacity: 0.85 });
        const ruinsWall = new THREE.MeshLambertMaterial({ color: 0x7a5a7a, transparent: true, opacity: 0.9 });
        const ruinsCeiling = new THREE.MeshLambertMaterial({ color: 0x5a3a5a, transparent: true, opacity: 0.7 });
        
        this.materials.set('ruins_floor', ruinsFloor);
        this.materials.set('ruins_wall', ruinsWall);
        this.materials.set('ruins_ceiling', ruinsCeiling);
    }
    
    createCryptMaterials() {
        const cryptFloor = new THREE.MeshLambertMaterial({ color: 0x3a3a2a, transparent: true, opacity: 0.9 });
        const cryptWall = new THREE.MeshLambertMaterial({ color: 0x4a4a3a, transparent: true, opacity: 0.95 });
        const cryptCeiling = new THREE.MeshLambertMaterial({ color: 0x2a2a1a, transparent: true, opacity: 0.6 });
        
        this.materials.set('crypt_floor', cryptFloor);
        this.materials.set('crypt_wall', cryptWall);
        this.materials.set('crypt_ceiling', cryptCeiling);
    }
    
    createForestMaterials() {
        const forestFloor = new THREE.MeshLambertMaterial({ color: 0x2a4a2a, transparent: true, opacity: 0.8 });
        const forestWall = new THREE.MeshLambertMaterial({ color: 0x3a5a3a, transparent: true, opacity: 0.7 });
        const forestCeiling = new THREE.MeshLambertMaterial({ color: 0x1a3a1a, transparent: true, opacity: 0.5 });
        
        this.materials.set('forest_floor', forestFloor);
        this.materials.set('forest_wall', forestWall);
        this.materials.set('forest_ceiling', forestCeiling);
    }
    
    setupBillboardSystem() {
        this.billboardGeometry = new THREE.PlaneGeometry(1, 1);
        this.createBillboardMaterials();
    }
    
    createBillboardMaterials() {
        const mushroomMaterial = new THREE.MeshBasicMaterial({ color: 0x4a8a4a, transparent: true, opacity: 0.8, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
        const crystalSpriteMaterial = new THREE.MeshBasicMaterial({ color: 0x6a4aaa, transparent: true, opacity: 0.9, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
        const orbMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaa4a, transparent: true, opacity: 0.7, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
        const runeMaterial = new THREE.MeshBasicMaterial({ color: 0x8a6a8a, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
        const treeMaterial = new THREE.MeshBasicMaterial({ color: 0x4a6a8a, transparent: true, opacity: 0.6, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
        
        this.materials.set('mushroom_billboard', mushroomMaterial);
        this.materials.set('crystal_billboard', crystalSpriteMaterial);
        this.materials.set('orb_billboard', orbMaterial);
        this.materials.set('rune_billboard', runeMaterial);
        this.materials.set('tree_billboard', treeMaterial);
    }
    
    getCurrentTheme() {
        for (const [themeName, themeData] of Object.entries(this.themes)) {
            if (this.currentFloor >= themeData.floors[0] && this.currentFloor <= themeData.floors[1]) {
                return themeData.name;
            }
        }
        return 'forest';
    }
    
    generateDungeon(floorNumber) {
        console.log(`Generating unified dungeon for floor ${floorNumber}...`);
        
        this.currentFloor = floorNumber;
        this.clearCurrentDungeon();
        
        const theme = this.getCurrentTheme();
        console.log(`Using theme: ${theme}`);
        
        // Phase 1: Plan room layout
        const roomLayout = this.planRoomLayout();
        
        // Phase 2: Create unified floor map
        const floorMap = this.createFloorMap(roomLayout);
        
        // Phase 3: Generate unified geometry
        this.generateUnifiedGeometry(floorMap, theme);
        
        // Phase 4: Add lighting and atmosphere
        this.addDungeonLighting(roomLayout, theme);
        this.addAtmosphericElements(roomLayout, theme);
        
        // Store dungeon data
        this.currentDungeon = {
            floor: floorNumber,
            theme: theme,
            roomLayout: roomLayout,
            floorMap: floorMap
        };
        
        console.log(`Unified dungeon floor ${floorNumber} generated successfully`);
        return this.currentDungeon;
    }
    
    planRoomLayout() {
        console.log('Planning room layout...');
        
        const layout = {
            rooms: {},
            connections: []
        };
        
        // Center room at origin
        layout.rooms.center = {
            id: 'center',
            type: 'center',
            gridX: Math.floor(this.gridWidth / 2),
            gridZ: Math.floor(this.gridDepth / 2),
            size: this.roomTemplates.CENTER.size
        };
        
        // Four orbital rooms in cardinal directions
        const orbitalDistance = 25; // Grid cells from center
        const orbitals = [
            { id: 'orbital_north', dir: 'north', offsetX: 0, offsetZ: -orbitalDistance },
            { id: 'orbital_south', dir: 'south', offsetX: 0, offsetZ: orbitalDistance },
            { id: 'orbital_east', dir: 'east', offsetX: orbitalDistance, offsetZ: 0 },
            { id: 'orbital_west', dir: 'west', offsetX: -orbitalDistance, offsetZ: 0 }
        ];
        
        orbitals.forEach(orbital => {
            layout.rooms[orbital.id] = {
                id: orbital.id,
                type: 'orbital',
                direction: orbital.dir,
                gridX: layout.rooms.center.gridX + orbital.offsetX,
                gridZ: layout.rooms.center.gridZ + orbital.offsetZ,
                size: this.roomTemplates.ORBITAL.size
            };
            
            // Connect to center
            layout.connections.push({
                from: 'center',
                to: orbital.id,
                type: 'center_to_orbital'
            });
        });
        
        // Cardinal rooms (chance-based)
        const cardinalChance = Math.min(0.3 + (this.currentFloor * 0.02), 0.8);
        const cardinalDistance = 25; // Additional distance from orbital
        
        orbitals.forEach(orbital => {
            if (Math.random() < cardinalChance) {
                const cardinalId = `cardinal_${orbital.dir}`;
                
                layout.rooms[cardinalId] = {
                    id: cardinalId,
                    type: 'cardinal',
                    direction: orbital.dir,
                    gridX: layout.rooms.center.gridX + orbital.offsetX + (orbital.offsetX > 0 ? cardinalDistance : orbital.offsetX < 0 ? -cardinalDistance : 0),
                    gridZ: layout.rooms.center.gridZ + orbital.offsetZ + (orbital.offsetZ > 0 ? cardinalDistance : orbital.offsetZ < 0 ? -cardinalDistance : 0),
                    size: this.roomTemplates.CARDINAL.size
                };
                
                // Connect to orbital
                layout.connections.push({
                    from: orbital.id,
                    to: cardinalId,
                    type: 'orbital_to_cardinal'
                });
            }
        });
        
        console.log(`Planned ${Object.keys(layout.rooms).length} rooms with ${layout.connections.length} connections`);
        return layout;
    }
    
    createFloorMap(roomLayout) {
        console.log('Creating unified floor map...');
        
        // Initialize grid (false = wall/solid, true = walkable)
        const floorMap = Array(this.gridDepth).fill().map(() => Array(this.gridWidth).fill(false));
        
        // Phase 1: Carve out room areas
        Object.values(roomLayout.rooms).forEach(room => {
            this.carveRoomArea(floorMap, room);
        });
        
        // Phase 2: Carve corridor paths
        roomLayout.connections.forEach(connection => {
            this.carveCorridorPath(floorMap, roomLayout.rooms[connection.from], roomLayout.rooms[connection.to]);
        });
        
        console.log('Floor map created with carved rooms and corridors');
        return floorMap;
    }
    
    carveRoomArea(floorMap, room) {
        const halfSize = Math.floor(room.size / 2);
        
        for (let z = room.gridZ - halfSize; z <= room.gridZ + halfSize; z++) {
            for (let x = room.gridX - halfSize; x <= room.gridX + halfSize; x++) {
                if (this.isValidGridPos(x, z)) {
                    floorMap[z][x] = true; // Mark as walkable
                }
            }
        }
        
        console.log(`Carved ${room.type} room at grid (${room.gridX}, ${room.gridZ}) size ${room.size}`);
    }
    
    carveCorridorPath(floorMap, roomA, roomB) {
        // Use L-shaped corridors: go horizontal first, then vertical
        const startX = roomA.gridX;
        const startZ = roomA.gridZ;
        const endX = roomB.gridX;
        const endZ = roomB.gridZ;
        
        const corridorHalfWidth = Math.floor(this.corridorWidth / 2);
        
        // Horizontal segment
        const minX = Math.min(startX, endX);
        const maxX = Math.max(startX, endX);
        
        for (let x = minX; x <= maxX; x++) {
            for (let zOffset = -corridorHalfWidth; zOffset <= corridorHalfWidth; zOffset++) {
                const z = startZ + zOffset;
                if (this.isValidGridPos(x, z)) {
                    floorMap[z][x] = true;
                }
            }
        }
        
        // Vertical segment
        const minZ = Math.min(startZ, endZ);
        const maxZ = Math.max(startZ, endZ);
        
        for (let z = minZ; z <= maxZ; z++) {
            for (let xOffset = -corridorHalfWidth; xOffset <= corridorHalfWidth; xOffset++) {
                const x = endX + xOffset;
                if (this.isValidGridPos(x, z)) {
                    floorMap[z][x] = true;
                }
            }
        }
        
        console.log(`Carved L-shaped corridor from (${startX},${startZ}) to (${endX},${endZ})`);
    }
    
    isValidGridPos(x, z) {
        return x >= 0 && x < this.gridWidth && z >= 0 && z < this.gridDepth;
    }
    
    generateUnifiedGeometry(floorMap, theme) {
        console.log('Generating unified geometry...');
        
        const dungeonGroup = new THREE.Group();
        dungeonGroup.name = 'unified_dungeon';
        
        // Generate unified floor
        this.generateUnifiedFloor(dungeonGroup, floorMap, theme);
        
        // Generate walls around walkable areas
        this.generateWallsFromMap(dungeonGroup, floorMap, theme);
        
        // Generate unified ceiling
        this.generateUnifiedCeiling(dungeonGroup, floorMap, theme);
        
        this.scene.add(dungeonGroup);
        this.currentDungeonGroup = dungeonGroup;
    }
    
    generateUnifiedFloor(dungeonGroup, floorMap, theme) {
        const floorMaterial = this.materials.get(`${theme}_floor`);
        const floorSegments = [];
        
        // Find connected floor regions and create efficient meshes
        for (let z = 0; z < this.gridDepth; z++) {
            for (let x = 0; x < this.gridWidth; x++) {
                if (floorMap[z][x]) {
                    // Create floor segment
                    const worldX = (x - this.gridWidth/2) * this.gridSize;
                    const worldZ = (z - this.gridDepth/2) * this.gridSize;
                    
                    const floorGeometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize);
                    const floorSegment = new THREE.Mesh(floorGeometry, floorMaterial);
                    floorSegment.rotation.x = -Math.PI / 2;
                    floorSegment.position.set(worldX, 0, worldZ);
                    floorSegment.receiveShadow = true;
                    
                    dungeonGroup.add(floorSegment);
                }
            }
        }
        
        console.log('Generated unified floor geometry');
    }
    
    generateWallsFromMap(dungeonGroup, floorMap, theme) {
        const wallMaterial = this.materials.get(`${theme}_wall`);
        const wallHeight = this.ceilingHeight;
        
        // March around perimeter of walkable areas to create walls
        for (let z = 0; z < this.gridDepth; z++) {
            for (let x = 0; x < this.gridWidth; x++) {
                if (floorMap[z][x]) {
                    // Check all 4 directions for wall placement
                    const directions = [
                        { dx: 0, dz: -1, wallX: 0, wallZ: -this.gridSize/2, rotY: 0 }, // North wall
                        { dx: 0, dz: 1, wallX: 0, wallZ: this.gridSize/2, rotY: 0 },  // South wall  
                        { dx: 1, dz: 0, wallX: this.gridSize/2, wallZ: 0, rotY: Math.PI/2 }, // East wall
                        { dx: -1, dz: 0, wallX: -this.gridSize/2, wallZ: 0, rotY: Math.PI/2 } // West wall
                    ];
                    
                    directions.forEach(dir => {
                        const neighborX = x + dir.dx;
                        const neighborZ = z + dir.dz;
                        
                        // Place wall if neighbor is solid or out of bounds
                        if (!this.isValidGridPos(neighborX, neighborZ) || !floorMap[neighborZ][neighborX]) {
                            const worldX = (x - this.gridWidth/2) * this.gridSize + dir.wallX;
                            const worldZ = (z - this.gridDepth/2) * this.gridSize + dir.wallZ;
                            
                            const wallGeometry = new THREE.BoxGeometry(this.gridSize, wallHeight, 0.5);
                            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                            wall.position.set(worldX, wallHeight/2, worldZ);
                            wall.rotation.y = dir.rotY;
                            wall.castShadow = true;
                            wall.receiveShadow = true;
                            
                            dungeonGroup.add(wall);
                        }
                    });
                }
            }
        }
        
        console.log('Generated unified wall geometry');
    }
    
    generateUnifiedCeiling(dungeonGroup, floorMap, theme) {
        const ceilingMaterial = this.materials.get(`${theme}_ceiling`);
        
        // Create ceiling segments over walkable areas
        for (let z = 0; z < this.gridDepth; z++) {
            for (let x = 0; x < this.gridWidth; x++) {
                if (floorMap[z][x]) {
                    const worldX = (x - this.gridWidth/2) * this.gridSize;
                    const worldZ = (z - this.gridDepth/2) * this.gridSize;
                    
                    const ceilingGeometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize);
                    const ceilingSegment = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                    ceilingSegment.rotation.x = Math.PI / 2;
                    ceilingSegment.position.set(worldX, this.ceilingHeight, worldZ);
                    ceilingSegment.receiveShadow = true;
                    
                    dungeonGroup.add(ceilingSegment);
                }
            }
        }
        
        console.log('Generated unified ceiling geometry');
    }
    
    addDungeonLighting(roomLayout, theme) {
        console.log('Adding dungeon lighting...');
        
        // Add bright test lighting to each room
        Object.values(roomLayout.rooms).forEach(room => {
            this.addRoomLighting(room, theme);
        });
        
        // Add corridor lighting
        roomLayout.connections.forEach(connection => {
            this.addCorridorLighting(roomLayout.rooms[connection.from], roomLayout.rooms[connection.to], theme);
        });
    }
    
    addRoomLighting(room, theme) {
        const worldX = (room.gridX - this.gridWidth/2) * this.gridSize;
        const worldZ = (room.gridZ - this.gridDepth/2) * this.gridSize;
        
        // Super bright overhead light
        const brightLight = new THREE.PointLight(0xffffff, 3.0, 50);
        brightLight.position.set(worldX, this.ceilingHeight - 1, worldZ);
        this.currentDungeonGroup.add(brightLight);
        this.lightSources.push(brightLight);
        
        // Corner lights for even coverage
        const roomSize = room.size * this.gridSize;
        const cornerPositions = [
            [worldX - roomSize/3, this.ceilingHeight/2, worldZ - roomSize/3],
            [worldX + roomSize/3, this.ceilingHeight/2, worldZ - roomSize/3],
            [worldX - roomSize/3, this.ceilingHeight/2, worldZ + roomSize/3],
            [worldX + roomSize/3, this.ceilingHeight/2, worldZ + roomSize/3]
        ];
        
        cornerPositions.forEach(pos => {
            const cornerLight = new THREE.PointLight(0xffffff, 2.0, 30);
            cornerLight.position.set(...pos);
            this.currentDungeonGroup.add(cornerLight);
            this.lightSources.push(cornerLight);
        });
        
        console.log(`Added bright lighting to ${room.type} room at (${worldX}, ${worldZ})`);
    }
    
    addCorridorLighting(roomA, roomB, theme) {
        const startWorldX = (roomA.gridX - this.gridWidth/2) * this.gridSize;
        const startWorldZ = (roomA.gridZ - this.gridDepth/2) * this.gridSize;
        const endWorldX = (roomB.gridX - this.gridWidth/2) * this.gridSize;
        const endWorldZ = (roomB.gridZ - this.gridDepth/2) * this.gridSize;
        
        // Light at corner of L-shaped corridor
        const cornerLight = new THREE.PointLight(0xffffff, 2.5, 40);
        cornerLight.position.set(endWorldX, 4, startWorldZ); // Corner position
        this.currentDungeonGroup.add(cornerLight);
        this.lightSources.push(cornerLight);
        
        // Additional lights along corridor path
        const midWorldX = (startWorldX + endWorldX) / 2;
        const midWorldZ = (startWorldZ + endWorldZ) / 2;
        
        const midLight = new THREE.PointLight(0xffffff, 1.8, 25);
        midLight.position.set(midWorldX, 3.5, midWorldZ);
        this.currentDungeonGroup.add(midLight);
        this.lightSources.push(midLight);
    }
    
    addAtmosphericElements(roomLayout, theme) {
        console.log('Adding atmospheric elements...');
        
        Object.values(roomLayout.rooms).forEach(room => {
            this.addRoomAtmosphere(room, theme);
        });
    }
    
    addRoomAtmosphere(room, theme) {
        const worldX = (room.gridX - this.gridWidth/2) * this.gridSize;
        const worldZ = (room.gridZ - this.gridDepth/2) * this.gridSize;
        const roomSize = room.size * this.gridSize;
        
        // Add theme-specific atmospheric elements
        switch (theme) {
            case 'stone':
                this.addStoneAtmosphere(worldX, worldZ, roomSize, room.type);
                break;
            case 'crystal':
                this.addCrystalAtmosphere(worldX, worldZ, roomSize, room.type);
                break;
            case 'ruins':
                this.addRuinsAtmosphere(worldX, worldZ, roomSize, room.type);
                break;
            case 'crypt':
                this.addCryptAtmosphere(worldX, worldZ, roomSize, room.type);
                break;
            case 'forest':
                this.addForestAtmosphere(worldX, worldZ, roomSize, room.type);
                break;
        }
        
        // Add floating orbs to all rooms
        this.addFloatingOrbs(worldX, worldZ, roomSize, theme);
    }
    
    addStoneAtmosphere(worldX, worldZ, roomSize, roomType) {
        // Stone pillars
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const radius = roomSize * 0.3;
            
            const pillarX = worldX + Math.cos(angle) * radius;
            const pillarZ = worldZ + Math.sin(angle) * radius;
            
            const pillarGeometry = new THREE.CylinderGeometry(0.6, 0.8, 4, 8);
            const pillarMaterial = this.materials.get('stone_wall');
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.set(pillarX, 2, pillarZ);
            pillar.castShadow = true;
            pillar.receiveShadow = true;
            this.currentDungeonGroup.add(pillar);
            
            // Torch light on pillar
            const torchLight = new THREE.PointLight(0xff6644, 0.8, 8);
            torchLight.position.set(pillarX, 3.5, pillarZ);
            this.currentDungeonGroup.add(torchLight);
            this.lightSources.push(torchLight);
        }
    }
    
    addCrystalAtmosphere(worldX, worldZ, roomSize, roomType) {
        // Crystal formations
        for (let i = 0; i < 6; i++) {
            const crystalX = worldX + (Math.random() - 0.5) * roomSize * 0.8;
            const crystalZ = worldZ + (Math.random() - 0.5) * roomSize * 0.8;
            
            const crystalGeometry = new THREE.ConeGeometry(0.4, 2.5, 6);
            const crystalMaterial = new THREE.MeshPhongMaterial({
                color: 0x6c5ce7,
                transparent: true,
                opacity: 0.8,
                emissive: 0x2d1b69,
                emissiveIntensity: 0.3
            });
            
            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
            crystal.position.set(crystalX, 1.25, crystalZ);
            crystal.rotation.y = Math.random() * Math.PI * 2;
            this.currentDungeonGroup.add(crystal);
            
            // Crystal glow
            const crystalLight = new THREE.PointLight(0x8a6ae7, 0.6, 6);
            crystalLight.position.set(crystalX, 2, crystalZ);
            this.currentDungeonGroup.add(crystalLight);
            this.lightSources.push(crystalLight);
        }
    }
    
    addRuinsAtmosphere(worldX, worldZ, roomSize, roomType) {
        // Runed stones
        for (let i = 0; i < 4; i++) {
            const runeX = worldX + (Math.random() - 0.5) * roomSize * 0.6;
            const runeZ = worldZ + (Math.random() - 0.5) * roomSize * 0.6;
            
            const runeGeometry = new THREE.BoxGeometry(1, 2, 0.3);
            const runeMaterial = new THREE.MeshLambertMaterial({
                color: 0x7a5a7a,
                emissive: 0x3a1a3a,
                emissiveIntensity: 0.2
            });
            
            const runeStone = new THREE.Mesh(runeGeometry, runeMaterial);
            runeStone.position.set(runeX, 1, runeZ);
            runeStone.rotation.y = Math.random() * Math.PI * 2;
            this.currentDungeonGroup.add(runeStone);
            
            // Rune glow
            const runeLight = new THREE.PointLight(0xaa6aaa, 0.4, 5);
            runeLight.position.set(runeX, 1.5, runeZ);
            this.currentDungeonGroup.add(runeLight);
            this.lightSources.push(runeLight);
        }
    }
    
    addCryptAtmosphere(worldX, worldZ, roomSize, roomType) {
        // Ancient braziers
        for (let i = 0; i < 3; i++) {
            const angle = (i / 3) * Math.PI * 2;
            const radius = roomSize * 0.4;
            
            const brazierX = worldX + Math.cos(angle) * radius;
            const brazierZ = worldZ + Math.sin(angle) * radius;
            
            // Brazier stand
            const brazierGeometry = new THREE.CylinderGeometry(0.5, 0.3, 1.5, 8);
            const brazierMaterial = this.materials.get('crypt_wall');
            const brazier = new THREE.Mesh(brazierGeometry, brazierMaterial);
            brazier.position.set(brazierX, 0.75, brazierZ);
            this.currentDungeonGroup.add(brazier);
            
            // Green flame light
            const brazierLight = new THREE.PointLight(0x44aa44, 0.8, 8);
            brazierLight.position.set(brazierX, 2.5, brazierZ);
            this.currentDungeonGroup.add(brazierLight);
            this.lightSources.push(brazierLight);
        }
    }
    
    addForestAtmosphere(worldX, worldZ, roomSize, roomType) {
        // Glowing mushroom clusters
        for (let i = 0; i < 8; i++) {
            const mushroomX = worldX + (Math.random() - 0.5) * roomSize * 0.8;
            const mushroomZ = worldZ + (Math.random() - 0.5) * roomSize * 0.8;
            
            const mushroomGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const mushroomMaterial = new THREE.MeshBasicMaterial({
                color: 0x4a8a4a,
                transparent: true,
                opacity: 0.7,
                emissive: 0x2a5a2a,
                emissiveIntensity: 0.4
            });
            
            const mushroom = new THREE.Mesh(mushroomGeometry, mushroomMaterial);
            mushroom.position.set(mushroomX, 0.3, mushroomZ);
            mushroom.scale.set(1 + Math.random() * 0.5, 1, 1 + Math.random() * 0.5);
            this.currentDungeonGroup.add(mushroom);
            
            // Mushroom glow
            const mushroomLight = new THREE.PointLight(0x6aaa6a, 0.5, 4);
            mushroomLight.position.set(mushroomX, 1, mushroomZ);
            this.currentDungeonGroup.add(mushroomLight);
            this.lightSources.push(mushroomLight);
        }
    }
    
    addFloatingOrbs(worldX, worldZ, roomSize, theme) {
        const numOrbs = 2 + Math.floor(Math.random() * 3);
        const themeColor = this.getThemeColor(theme);
        
        for (let i = 0; i < numOrbs; i++) {
            const orbGeometry = new THREE.SphereGeometry(0.15, 12, 8);
            const orbMaterial = new THREE.MeshBasicMaterial({
                color: themeColor,
                transparent: true,
                opacity: 0.8,
                emissive: themeColor,
                emissiveIntensity: 0.5
            });
            
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            orb.position.set(
                worldX + (Math.random() - 0.5) * roomSize * 0.6,
                4 + Math.random() * 2,
                worldZ + (Math.random() - 0.5) * roomSize * 0.6
            );
            
            // Add floating animation
            orb.userData = {
                originalY: orb.position.y,
                floatSpeed: 0.5 + Math.random() * 1.5,
                floatAmount: 0.3 + Math.random() * 0.4
            };
            
            this.currentDungeonGroup.add(orb);
            
            // Orb light
            const orbLight = new THREE.PointLight(themeColor, 0.3, 5);
            orbLight.position.copy(orb.position);
            this.currentDungeonGroup.add(orbLight);
            this.lightSources.push(orbLight);
        }
    }
    
    getThemeColor(theme) {
        const colors = {
            stone: 0xff6644,
            crystal: 0x8a6ae7,
            ruins: 0xaa6aaa,
            crypt: 0x44aa44,
            forest: 0x6aaa6a
        };
        return colors[theme] || 0xffffff;
    }
    
    update(deltaTime) {
        // Update floating orbs and animated elements
        if (this.currentDungeonGroup) {
            this.currentDungeonGroup.traverse((child) => {
                if (child.userData.floatSpeed && child.userData.originalY !== undefined) {
                    child.position.y = child.userData.originalY + 
                        Math.sin(Date.now() * 0.001 * child.userData.floatSpeed) * child.userData.floatAmount;
                }
            });
        }
        
        // Animate light intensities
        this.lightSources.forEach(light => {
            if (light.userData.originalIntensity === undefined) {
                light.userData.originalIntensity = light.intensity;
                light.userData.flickerSpeed = 0.5 + Math.random() * 2;
            }
            
            const flicker = Math.sin(Date.now() * 0.001 * light.userData.flickerSpeed) * 0.1 + 1;
            light.intensity = light.userData.originalIntensity * flicker;
        });
    }
    
    clearCurrentDungeon() {
        if (this.currentDungeonGroup) {
            this.scene.remove(this.currentDungeonGroup);
        }
        
        this.lightSources.length = 0;
        this.billboardSprites.length = 0;
        
        console.log('Previous dungeon cleared');
    }
    
    getRoomAt(position) {
        if (!this.currentDungeon) return null;
        
        // Convert world position to grid position
        const gridX = Math.floor((position.x + this.dungeonWidth/2) / this.gridSize);
        const gridZ = Math.floor((position.z + this.dungeonDepth/2) / this.gridSize);
        
        // Find which room contains this grid position
        for (const room of Object.values(this.currentDungeon.roomLayout.rooms)) {
            const halfSize = Math.floor(room.size / 2);
            if (gridX >= room.gridX - halfSize && gridX <= room.gridX + halfSize &&
                gridZ >= room.gridZ - halfSize && gridZ <= room.gridZ + halfSize) {
                return room;
            }
        }
        
        return null;
    }
}

// Make DungeonSystem available globally
window.DungeonSystem = DungeonSystem;
    </script>
    
    <!-- 5. MAIN GAME ENGINE (INLINE - GUARANTEED TO LOAD AFTER DEPENDENCIES) -->
    <script>
        // Main Game Engine with proper initialization sequencing
        class LabyrinthGame {
            constructor() {
                console.log('Initializing Labyrinth Game...');
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.dungeonSystem = null;
                
                // Game state
                this.gameState = 'loading'; // loading, playing, paused, menu
                this.currentFloor = 1;
                this.gameTime = 0;
                
                // Performance
                this.clock = new THREE.Clock();
                this.frameCount = 0;
                
                // Input handling
                this.isPointerLocked = false;
                
                // Initialization phases
                this.initializationPhases = [
                    'scene',
                    'renderer', 
                    'camera',
                    'lighting',
                    'player',
                    'dungeon',
                    'ui',
                    'complete'
                ];
                this.currentPhase = 0;
                
                this.init();
            }
            
            async init() {
                console.log('Starting game initialization sequence...');
                
                try {
                    // Execute each initialization phase in sequence
                    for (let i = 0; i < this.initializationPhases.length; i++) {
                        const phase = this.initializationPhases[i];
                        console.log(`Initializing phase: ${phase}`);
                        
                        await this.executePhase(phase);
                        this.currentPhase = i;
                        
                        // Small delay to prevent blocking
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    // All systems loaded - start game
                    this.gameState = 'playing';
                    console.log('Game initialization complete - starting game loop');
                    this.gameLoop();
                    
                } catch (error) {
                    console.error('Failed to initialize game:', error);
                    this.gameState = 'error';
                }
            }
            
            async executePhase(phase) {
                switch(phase) {
                    case 'scene':
                        this.setupScene();
                        break;
                    case 'renderer':
                        this.setupRenderer();
                        break;
                    case 'camera':
                        this.setupCamera();
                        break;
                    case 'lighting':
                        this.setupLighting();
                        break;
                    case 'player':
                        this.setupPlayer();
                        break;
                    case 'dungeon':
                        this.setupDungeon();
                        break;
                    case 'ui':
                        this.setupUI();
                        break;
                    case 'complete':
                        this.onInitializationComplete();
                        break;
                }
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x1a1a2e, 0.02);
                this.scene.background = new THREE.Color(0x0f0f1f);
            }
            
            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Enhanced rendering settings for atmosphere
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 0.6;
                
                const gameContainer = document.getElementById('gameContainer');
                if (gameContainer) {
                    gameContainer.appendChild(this.renderer.domElement);
                } else {
                    console.error('gameContainer element not found!');
                }
                
                // Set up pointer lock for desktop
                if (!inputState.isMobile) {
                    this.renderer.domElement.addEventListener('click', () => {
                        this.requestPointerLock();
                    });
                    
                    document.addEventListener('pointerlockchange', () => {
                        this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                    });
                }
            }
            
            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 1.8, 0);
                
                // Window resize handler
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupLighting() {
                // Much brighter ambient lighting for testing
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambientLight);
                
                // Brighter main directional light for testing
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(10, 20, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 100;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
            }
            
            setupPlayer() {
                // CRITICAL: Only create player AFTER scene is ready
                if (!this.scene || !this.camera) {
                    throw new Error('Scene and camera must be initialized before player');
                }
                
                console.log('Creating player - scene is ready');
                this.player = new Player(this.scene, this.camera);
            }
            
            setupDungeon() {
                // Initialize dungeon system AFTER player is created
                if (!this.player) {
                    throw new Error('Player must be initialized before dungeon system');
                }
                
                console.log('Creating dungeon system...');
                this.dungeonSystem = new DungeonSystem(this.scene, this.player);
                
                // Generate the first dungeon floor
                console.log('Generating first dungeon floor...');
                this.dungeonSystem.generateDungeon(this.currentFloor);
                
                // Position player in center room
                this.player.position.set(0, 1.8, 0);
                this.player.camera.position.copy(this.player.position);
                
                console.log('Dungeon system initialized and first floor generated');
            }
            
            setupUI() {
                this.updateUI();
            }
            
            onInitializationComplete() {
                console.log('All systems initialized successfully');
                
                // Set up additional input handlers now that everything is ready
                if (!inputState.isMobile) {
                    document.addEventListener('keydown', (e) => {
                        if (e.code === 'Escape' && this.isPointerLocked) {
                            document.exitPointerLock();
                        }
                    });
                }
                
                // Update floor indicator
                this.updateFloorIndicator();
            }
            
            requestPointerLock() {
                if (!inputState.isMobile) {
                    this.renderer.domElement.requestPointerLock();
                }
            }
            
            update(deltaTime) {
                // Only update if game is playing
                if (this.gameState !== 'playing') return;
                
                this.gameTime += deltaTime;
                this.frameCount++;
                
                // Get current input state
                const input = getInput();
                
                // Update player (only if initialized)
                if (this.player) {
                    this.player.update(deltaTime, input);
                }
                
                // Update dungeon system (animated elements, lighting, etc.)
                if (this.dungeonSystem) {
                    this.dungeonSystem.update(deltaTime);
                }
                
                // Reset mouse delta
                inputState.mouse.deltaX = 0;
                inputState.mouse.deltaY = 0;
                
                // Update UI
                this.updateUI();
                
                // Check for floor progression (placeholder - will be replaced with key system)
                this.checkFloorProgression(input);
            }
            
            checkFloorProgression(input) {
                // Menu button: Skip 10 floors ahead for testing
                if (input.justPressed.menu) {
                    this.advanceFloors(10);
                }
                
                // E + Esc together: Advance 1 floor for fine testing
                if (input.justPressed.interact && input.menu) {
                    this.advanceFloors(1);
                }
            }
            
            advanceFloors(count) {
                this.currentFloor += count;
                console.log(`Advancing ${count} floors to floor ${this.currentFloor}`);
                
                // Generate new dungeon floor
                if (this.dungeonSystem) {
                    this.dungeonSystem.generateDungeon(this.currentFloor);
                }
                
                // Reset player position to center
                this.player.position.set(0, 1.8, 0);
                this.player.velocity.set(0, 0, 0);
                this.player.camera.position.copy(this.player.position);
                
                // Update UI
                this.updateFloorIndicator();
            }
            
            advanceToNextFloor() {
                // Keep this method for compatibility
                this.advanceFloors(1);
            }
            
            updateFloorIndicator() {
                const floorElement = document.getElementById('floorIndicator');
                if (floorElement) {
                    const theme = this.dungeonSystem ? this.dungeonSystem.getCurrentTheme() : 'stone';
                    floorElement.textContent = `Floor ${this.currentFloor} - ${theme.charAt(0).toUpperCase() + theme.slice(1)} Depths`;
                }
            }
            
            updateUI() {
                if (!this.player) return;
                
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                const staminaPercent = (this.player.stamina / this.player.maxStamina) * 100;
                const manaPercent = (this.player.mana / this.player.maxMana) * 100;
                
                const healthFill = document.getElementById('healthFill');
                const staminaFill = document.getElementById('staminaFill');
                const manaFill = document.getElementById('manaFill');
                
                if (healthFill) healthFill.style.width = healthPercent + '%';
                if (staminaFill) staminaFill.style.width = staminaPercent + '%';
                if (manaFill) manaFill.style.width = manaPercent + '%';
            }
            
            render() {
                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }
            }
            
            gameLoop() {
                const deltaTime = this.clock.getDelta();
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Make LabyrinthGame available globally
        window.LabyrinthGame = LabyrinthGame;
    </script>
    
    <!-- 6. GUARANTEED FINAL INITIALIZATION -->
    <script>
        // Wait for DOM to be fully loaded before starting
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing game...');
            
            // Verify all dependencies are loaded
            if (!window.THREE) {
                console.error('Three.js not loaded!');
                return;
            }
            
            if (!window.setupInput) {
                console.error('Input system not loaded!');
                return;
            }
            
            if (!window.Player) {
                console.error('Player system not loaded!');
                return;
            }
            
            if (!window.DungeonSystem) {
                console.error('Dungeon system not loaded!');
                return;
            }
            
            // Initialize input system first
            setupInput();
            
            // Initialize game engine (this will create player, dungeon, etc.)
            window.game = new LabyrinthGame();
            
            console.log('Game initialization complete');
        });
    </script>
</body>
</html>
