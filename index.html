<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Forest RTS - Map Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
            touch-action: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 25, 15, 0.85);
            border: 2px solid #4a7c3f;
            border-radius: 8px;
            padding: 15px;
            color: #a8d5a2;
            font-size: 12px;
            line-height: 1.6;
            pointer-events: auto;
            max-width: 280px;
        }

        #controls-help h3 {
            color: #7ddf64;
            margin-bottom: 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #controls-help .key {
            display: inline-block;
            background: #2d4a2d;
            border: 1px solid #5a8a5a;
            border-radius: 3px;
            padding: 2px 6px;
            margin: 0 2px;
            font-weight: bold;
            color: #c8f0c8;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 180px;
            height: 90px;
            background: rgba(15, 25, 15, 0.9);
            border: 2px solid #4a7c3f;
            border-radius: 4px;
            pointer-events: auto;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            border-radius: 2px;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(15, 25, 15, 0.85);
            border: 2px solid #4a7c3f;
            border-radius: 8px;
            padding: 15px;
            color: #a8d5a2;
            font-size: 13px;
            pointer-events: auto;
        }

        #info-panel h2 {
            color: #7ddf64;
            font-size: 16px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(74, 124, 63, 0.3);
        }

        .stat-label {
            color: #7a9a7a;
        }

        .stat-value {
            color: #c8f0c8;
            font-weight: bold;
        }

        .tree-legend {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid #4a7c3f;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .legend-color.normal { background: linear-gradient(135deg, #2d5a1e, #4a8c3a); }
        .legend-color.high-yield { background: linear-gradient(135deg, #1a3a12, #2d5a1e); }
        .legend-color.energy { background: linear-gradient(135deg, #6b2d8a, #9b4dca); }
        .legend-color.clearing { background: linear-gradient(135deg, #5a4a2a, #7a6a4a); }

        #mobile-controls {
            position: absolute;
            bottom: 100px;
            right: 20px;
            display: none;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: grid;
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
                gap: 5px;
            }

            #controls-help {
                display: none;
            }
        }

        .mobile-btn {
            width: 50px;
            height: 50px;
            background: rgba(15, 25, 15, 0.85);
            border: 2px solid #4a7c3f;
            border-radius: 8px;
            color: #7ddf64;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        .mobile-btn:active {
            background: #4a7c3f;
            color: #1a1a2e;
        }

        .mobile-btn.up { grid-column: 2; grid-row: 1; }
        .mobile-btn.down { grid-column: 2; grid-row: 3; }
        .mobile-btn.left { grid-column: 1; grid-row: 2; }
        .mobile-btn.right { grid-column: 3; grid-row: 2; }
        .mobile-btn.zoomin { grid-column: 1; grid-row: 1; }
        .mobile-btn.zoomout { grid-column: 3; grid-row: 1; }
        .mobile-btn.rotleft { grid-column: 1; grid-row: 3; }
        .mobile-btn.rotright { grid-column: 3; grid-row: 3; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="info-panel" style="display: none;">
                <h2>ðŸŒ² Forest Map</h2>
                <div class="stat-row">
                    <span class="stat-label">Grid Size:</span>
                    <span class="stat-value">200 Ã— 400</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Trees:</span>
                    <span class="stat-value" id="tree-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Camera Pos:</span>
                    <span class="stat-value" id="camera-pos">0, 0</span>
                </div>
                <div class="tree-legend">
                    <div class="legend-item">
                        <div class="legend-color normal"></div>
                        <span>Normal Tree</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color high-yield"></div>
                        <span>High-Yield Tree</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color energy"></div>
                        <span>Energy Tree</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color clearing"></div>
                        <span>Base Clearing</span>
                    </div>
                </div>
            </div>

            <canvas id="minimap-canvas"></canvas>
            <div id="minimap">
                <canvas id="minimap-canvas"></canvas>
            </div>

            <div id="debug-panel" style="
            display: none;
            position: absolute;
            bottom: 200px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 10px;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 9999;
            pointer-events: auto;
            border: 1px solid #0f0;
        "></div>

            <div id="controls-help">
                <h3>ðŸŽ® Controls</h3>
                <div><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> or <span class="key">Arrows</span> â€” Pan camera</div>
                <div><span class="key">Q</span><span class="key">E</span> â€” Rotate camera</div>
                <div><span class="key">R</span><span class="key">F</span> â€” Zoom in/out</div>
                <div><span class="key">Space</span> â€” Toggle top-down view</div>
                <div><span class="key">1</span><span class="key">2</span> â€” Jump to Player/Enemy base</div>
            </div>

            <div id="mobile-controls">
                <div class="mobile-btn zoomin" data-action="zoomin">+</div>
                <div class="mobile-btn up" data-action="up">â–²</div>
                <div class="mobile-btn zoomout" data-action="zoomout">âˆ’</div>
                <div class="mobile-btn left" data-action="left">â—„</div>
                <div class="mobile-btn down" data-action="down">â–¼</div>
                <div class="mobile-btn right" data-action="right">â–º</div>
                <div class="mobile-btn rotleft" data-action="rotleft">â†º</div>
                <div class="mobile-btn rotright" data-action="rotright">â†»</div>
            </div>
        </div>
    </div>

    <script>
        // Pre-Three.js check
        document.getElementById('debug-panel').innerHTML = 'Waiting for THREE.js...<br>';
        
        // Timeout check
        setTimeout(function() {
            var panel = document.getElementById('debug-panel');
            if (typeof THREE === 'undefined') {
                panel.innerHTML += '<span style="color:orange">THREE.js taking too long, trying backup CDN...</span><br>';
                var backup = document.createElement('script');
                backup.src = 'https://unpkg.com/three@0.128.0/build/three.min.js';
                backup.onload = function() {
                    panel.innerHTML += 'Backup CDN loaded!<br>';
                };
                backup.onerror = function() {
                    panel.innerHTML += '<span style="color:red">Backup CDN also failed!</span><br>';
                };
                document.head.appendChild(backup);
            }
        }, 3000);
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" 
            onload="document.getElementById('debug-panel').innerHTML += 'THREE.js loaded from primary CDN<br>'"
            onerror="document.getElementById('debug-panel').innerHTML += '<span style=color:red>PRIMARY CDN FAILED</span><br>'"></script>
    <script>
        // GLOBAL ERROR HANDLER
        window.onerror = function(msg, url, line, col, error) {
            var panel = document.getElementById('debug-panel');
            if (panel) {
                panel.innerHTML += '<span style="color:red">ERROR: ' + msg + ' at line ' + line + '</span><br>';
            }
            console.error('Global error:', msg, url, line);
            return false;
        };
        
        // IMMEDIATE DEBUG - First thing that runs
        (function() {
            var panel = document.getElementById('debug-panel');
            if (panel) panel.innerHTML = 'JS STARTED<br>';
        })();
        
        // Debug logging function
        function debug(msg) {
            console.log(msg);
            try {
                var panel = document.getElementById('debug-panel');
                if (panel) {
                    panel.innerHTML += msg + '<br>';
                    panel.scrollTop = panel.scrollHeight;
                }
            } catch(e) {
                console.log('Debug panel error:', e);
            }
        }
        
        debug('Debug function defined');
        debug('THREE exists: ' + (typeof THREE !== 'undefined'));
        
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            GRID_WIDTH: 200,
            GRID_HEIGHT: 400,
            CELL_SIZE: 1,
            
            // Clearing settings
            CLEARING_RADIUS: 25,
            CLEARING_PADDING: 30,
            
            // Tree distribution
            TREE_DENSITY: 0.7,
            HIGH_YIELD_EDGE_DISTANCE: 30,
            HIGH_YIELD_PROBABILITY: 0.4,
            ENERGY_CENTER_CLUSTER_RADIUS: 60,
            ENERGY_CENTER_PROBABILITY: 0.15,
            ENERGY_SCATTER_PROBABILITY: 0.02,
            
            // Visual settings
            TREE_SCALE_MIN: 0.8,
            TREE_SCALE_MAX: 1.4,
            
            // Camera
            CAMERA_SPEED: 0.5,
            ZOOM_SPEED: 2,
            ROTATE_SPEED: 0.03
        };
        
        debug('CONFIG defined');

        // ============================================
        // GAME STATE
        // ============================================
        const gameState = {
            grid: [],
            trees: [],
            buildings: [],
            units: [],
            playerBuildingSites: [],
            enemyBuildingSites: [],
            selectedSite: null,
            selectedBuilding: null,
            resources: {
                wood: 500,
                coal: 100,
                energy: 300
            },
            camera: {
                target: { x: CONFIG.GRID_WIDTH / 2, z: CONFIG.GRID_HEIGHT / 2 },
                distance: 80,
                angle: 0,
                pitch: Math.PI / 4,
                isTopDown: false
            },
            input: {
                keys: {},
                mobileActions: {}
            }
        };
        
        debug('gameState defined');
        
        // Raycaster for click detection - created lazily
        let raycaster = null;
        let mouse = null;
        
        function ensureRaycaster() {
            if (!raycaster) {
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
            }
        }
        
        debug('Raycaster setup defined');

        // Cell types
        const CELL = {
            EMPTY: 0,
            TREE_NORMAL: 1,
            TREE_HIGH_YIELD: 2,
            TREE_ENERGY: 3,
            CLEARING_PLAYER: 4,
            CLEARING_ENEMY: 5
        };
        
        debug('CELL types defined');
        debug('All top-level definitions complete');

        // ============================================
        // THREE.JS SETUP
        // ============================================
        let scene, camera, renderer;
        let treeGeometry, treeMaterials;

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2a1a);
            scene.fog = new THREE.Fog(0x1a2a1a, 50, 200);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Raycaster for click detection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffcc, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Ground plane
            createGround();

            // Initialize tree materials
            createTreeMaterials();

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(
                CONFIG.GRID_WIDTH * CONFIG.CELL_SIZE,
                CONFIG.GRID_HEIGHT * CONFIG.CELL_SIZE
            );
            
            // Create a canvas texture for the ground
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Base color
            ctx.fillStyle = '#3d5a3d';
            ctx.fillRect(0, 0, 512, 1024);
            
            // Add noise/variation
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 1024;
                const shade = Math.random() * 30 - 15;
                ctx.fillStyle = `rgb(${61 + shade}, ${90 + shade}, ${61 + shade})`;
                ctx.fillRect(x, y, 2, 2);
            }
            
            const groundTexture = new THREE.CanvasTexture(canvas);
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(4, 8);
            
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                map: groundTexture
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(
                CONFIG.GRID_WIDTH * CONFIG.CELL_SIZE / 2,
                0,
                CONFIG.GRID_HEIGHT * CONFIG.CELL_SIZE / 2
            );
            scene.add(ground);
        }

        function createTreeMaterials() {
            // Create pixel-art style tree textures
            treeMaterials = {
                normal: createNormalTreeMaterial(),
                highYield: createHighYieldTreeMaterial(),
                energy: createEnergyTreeMaterial()
            };
        }

        function createNormalTreeMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 96;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, 64, 96);
            
            // Trunk
            ctx.fillStyle = '#1a3a12';
            ctx.fillRect(26, 60, 12, 36);
            
            // Tree outline (darker)
            ctx.fillStyle = '#2d5a1e';
            ctx.beginPath();
            ctx.moveTo(32, 4);
            ctx.lineTo(8, 64);
            ctx.lineTo(56, 64);
            ctx.closePath();
            ctx.fill();
            
            // Tree inner (lighter)
            ctx.fillStyle = '#4a8c3a';
            ctx.beginPath();
            ctx.moveTo(32, 12);
            ctx.lineTo(16, 56);
            ctx.lineTo(48, 56);
            ctx.closePath();
            ctx.fill();
            
            // Pixel details
            ctx.fillStyle = '#2d5a1e';
            for (let i = 0; i < 8; i++) {
                const x = 20 + Math.random() * 24;
                const y = 20 + Math.random() * 30;
                ctx.fillRect(x, y, 4, 4);
            }
            
            // Border
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(32, 4);
            ctx.lineTo(8, 64);
            ctx.lineTo(56, 64);
            ctx.closePath();
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            
            return new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
        }

        function createHighYieldTreeMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 96;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, 64, 96);
            
            // Thick trunk
            ctx.fillStyle = '#2a1a0a';
            ctx.fillRect(24, 50, 16, 46);
            
            // Trunk texture/bark lines
            ctx.fillStyle = '#3d2a1a';
            ctx.fillRect(26, 52, 4, 40);
            ctx.fillRect(34, 54, 3, 38);
            
            // Trunk roots
            ctx.fillStyle = '#2a1a0a';
            ctx.beginPath();
            ctx.moveTo(16, 96);
            ctx.lineTo(24, 75);
            ctx.lineTo(28, 96);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(36, 96);
            ctx.lineTo(40, 78);
            ctx.lineTo(48, 96);
            ctx.fill();
            
            // Main canopy - cluster of round shapes (dark base)
            ctx.fillStyle = '#1a3a12';
            ctx.beginPath();
            ctx.arc(20, 38, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(44, 38, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(32, 28, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(32, 48, 16, 0, Math.PI * 2);
            ctx.fill();
            
            // Mid-tone layer
            ctx.fillStyle = '#2d4a1e';
            ctx.beginPath();
            ctx.arc(18, 34, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(46, 34, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(32, 22, 14, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(28, 44, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(38, 42, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight puffs
            ctx.fillStyle = '#3d5a2e';
            ctx.beginPath();
            ctx.arc(24, 28, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(40, 26, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(32, 16, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Bright spots
            ctx.fillStyle = '#4a6a3a';
            ctx.beginPath();
            ctx.arc(28, 20, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(38, 18, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(20, 30, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Dark detail spots for depth
            ctx.fillStyle = '#0f250a';
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 18;
                const x = 32 + Math.cos(angle) * dist;
                const y = 34 + Math.sin(angle) * dist * 0.7;
                ctx.fillRect(x, y, 4, 4);
            }
            
            // Outline
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(20, 38, 18, Math.PI * 0.5, Math.PI * 1.5);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(32, 28, 20, Math.PI * 1.2, Math.PI * 1.8);
            ctx.stroke();
            
            // Better outline - trace the outer edge
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(4, 44);
            ctx.quadraticCurveTo(2, 28, 16, 14);
            ctx.quadraticCurveTo(32, 2, 48, 14);
            ctx.quadraticCurveTo(62, 28, 60, 44);
            ctx.quadraticCurveTo(58, 58, 44, 58);
            ctx.quadraticCurveTo(32, 62, 20, 58);
            ctx.quadraticCurveTo(6, 56, 4, 44);
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            
            return new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
        }

        function createEnergyTreeMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 96;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, 64, 96);
            
            // Outer glow
            const glowGradient = ctx.createRadialGradient(32, 40, 5, 32, 40, 35);
            glowGradient.addColorStop(0, 'rgba(180, 100, 255, 0.4)');
            glowGradient.addColorStop(0.5, 'rgba(140, 60, 200, 0.2)');
            glowGradient.addColorStop(1, 'rgba(100, 40, 150, 0)');
            ctx.fillStyle = glowGradient;
            ctx.fillRect(0, 0, 64, 80);
            
            // Crystal trunk
            ctx.fillStyle = '#4a2a6a';
            ctx.beginPath();
            ctx.moveTo(28, 55);
            ctx.lineTo(24, 96);
            ctx.lineTo(40, 96);
            ctx.lineTo(36, 55);
            ctx.closePath();
            ctx.fill();
            
            // Trunk crystal facets
            ctx.fillStyle = '#6a4a8a';
            ctx.beginPath();
            ctx.moveTo(30, 58);
            ctx.lineTo(28, 90);
            ctx.lineTo(34, 88);
            ctx.lineTo(33, 60);
            ctx.closePath();
            ctx.fill();
            
            // Main crystal body (outer)
            ctx.fillStyle = '#5a2d7a';
            ctx.beginPath();
            ctx.moveTo(32, 2);
            ctx.lineTo(6, 40);
            ctx.lineTo(14, 60);
            ctx.lineTo(50, 60);
            ctx.lineTo(58, 40);
            ctx.closePath();
            ctx.fill();
            
            // Crystal facet left
            ctx.fillStyle = '#7a4d9a';
            ctx.beginPath();
            ctx.moveTo(32, 8);
            ctx.lineTo(12, 38);
            ctx.lineTo(20, 55);
            ctx.lineTo(32, 35);
            ctx.closePath();
            ctx.fill();
            
            // Crystal facet right (brightest)
            ctx.fillStyle = '#9b6dba';
            ctx.beginPath();
            ctx.moveTo(32, 8);
            ctx.lineTo(32, 35);
            ctx.lineTo(44, 55);
            ctx.lineTo(52, 38);
            ctx.closePath();
            ctx.fill();
            
            // Inner glow core
            ctx.fillStyle = '#c8a0e8';
            ctx.beginPath();
            ctx.moveTo(32, 18);
            ctx.lineTo(24, 38);
            ctx.lineTo(32, 48);
            ctx.lineTo(40, 38);
            ctx.closePath();
            ctx.fill();
            
            // Bright center
            ctx.fillStyle = '#e8d0ff';
            ctx.beginPath();
            ctx.arc(32, 35, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Sparkle points
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(30, 14, 4, 4);
            ctx.fillRect(18, 36, 3, 3);
            ctx.fillRect(44, 32, 3, 3);
            ctx.fillRect(32, 46, 2, 2);
            ctx.fillRect(26, 28, 2, 2);
            ctx.fillRect(38, 24, 2, 2);
            
            // Floating particles
            ctx.fillStyle = 'rgba(200, 160, 255, 0.8)';
            ctx.fillRect(8, 20, 3, 3);
            ctx.fillRect(54, 28, 3, 3);
            ctx.fillRect(12, 48, 2, 2);
            ctx.fillRect(50, 52, 2, 2);
            ctx.fillRect(4, 38, 2, 2);
            ctx.fillRect(58, 44, 2, 2);
            
            // Crystal outline
            ctx.strokeStyle = '#3a1a5a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(32, 2);
            ctx.lineTo(6, 40);
            ctx.lineTo(14, 60);
            ctx.lineTo(50, 60);
            ctx.lineTo(58, 40);
            ctx.closePath();
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            
            return new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // MAP GENERATION
        // ============================================
        function generateMap() {
            // Initialize grid
            gameState.grid = [];
            for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                gameState.grid[x] = [];
                for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
                    gameState.grid[x][z] = CELL.EMPTY;
                }
            }

            // Define clearing positions
            const playerClearingCenter = {
                x: CONFIG.GRID_WIDTH / 2,
                z: CONFIG.CLEARING_PADDING
            };
            const enemyClearingCenter = {
                x: CONFIG.GRID_WIDTH / 2,
                z: CONFIG.GRID_HEIGHT - CONFIG.CLEARING_PADDING
            };

            // Mark clearings
            markClearing(playerClearingCenter, CELL.CLEARING_PLAYER);
            markClearing(enemyClearingCenter, CELL.CLEARING_ENEMY);

            // Create clearing visuals
            createClearingVisual(playerClearingCenter, 0x4a6a3a, 'Player Base');
            createClearingVisual(enemyClearingCenter, 0x6a4a3a, 'Enemy Base');

            // Generate trees
            const mapCenterZ = CONFIG.GRID_HEIGHT / 2;

            for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
                    // Skip if in a clearing
                    if (gameState.grid[x][z] !== CELL.EMPTY) continue;

                    // Check tree density
                    if (Math.random() > CONFIG.TREE_DENSITY) continue;

                    // Determine tree type
                    let treeType = CELL.TREE_NORMAL;

                    // Distance from edges (for high-yield)
                    const distFromLeftEdge = x;
                    const distFromRightEdge = CONFIG.GRID_WIDTH - x;
                    const minEdgeDist = Math.min(distFromLeftEdge, distFromRightEdge);

                    // Distance from center (for energy trees)
                    const distFromCenterZ = Math.abs(z - mapCenterZ);
                    const distFromCenterX = Math.abs(x - CONFIG.GRID_WIDTH / 2);
                    const distFromCenter = Math.sqrt(distFromCenterX * distFromCenterX + distFromCenterZ * distFromCenterZ);

                    // High-yield trees near edges
                    if (minEdgeDist < CONFIG.HIGH_YIELD_EDGE_DISTANCE) {
                        const edgeFactor = 1 - (minEdgeDist / CONFIG.HIGH_YIELD_EDGE_DISTANCE);
                        if (Math.random() < CONFIG.HIGH_YIELD_PROBABILITY * edgeFactor) {
                            treeType = CELL.TREE_HIGH_YIELD;
                        }
                    }

                    // Energy trees clustered in center with scatter
                    if (distFromCenter < CONFIG.ENERGY_CENTER_CLUSTER_RADIUS) {
                        const centerFactor = 1 - (distFromCenter / CONFIG.ENERGY_CENTER_CLUSTER_RADIUS);
                        if (Math.random() < CONFIG.ENERGY_CENTER_PROBABILITY * centerFactor) {
                            treeType = CELL.TREE_ENERGY;
                        }
                    } else if (Math.random() < CONFIG.ENERGY_SCATTER_PROBABILITY) {
                        treeType = CELL.TREE_ENERGY;
                    }

                    // Place tree
                    gameState.grid[x][z] = treeType;
                    createTree(x, z, treeType);
                }
            }

            // Update UI
            document.getElementById('tree-count').textContent = gameState.trees.length.toLocaleString();
            
            // Generate minimap
            generateMinimap();
        }

        function markClearing(center, cellType) {
            for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
                    const dx = x - center.x;
                    const dz = z - center.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < CONFIG.CLEARING_RADIUS) {
                        gameState.grid[x][z] = cellType;
                    }
                }
            }
        }

        function createClearingVisual(center, color, label) {
            // Clearing ground
            const clearingGeometry = new THREE.CircleGeometry(CONFIG.CLEARING_RADIUS, 32);
            const clearingMaterial = new THREE.MeshLambertMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const clearing = new THREE.Mesh(clearingGeometry, clearingMaterial);
            clearing.rotation.x = -Math.PI / 2;
            clearing.position.set(center.x, 0.01, center.z);
            scene.add(clearing);

            // Building placement indicators (16 spots: 2x2 center + 12 ring)
            const buildingSpots = [];
            
            // Center 2x2 (4 spots)
            const centerOffset = 4;
            buildingSpots.push({ x: -centerOffset, z: -centerOffset, id: 'center-0' });
            buildingSpots.push({ x: centerOffset, z: -centerOffset, id: 'center-1' });
            buildingSpots.push({ x: -centerOffset, z: centerOffset, id: 'center-2' });
            buildingSpots.push({ x: centerOffset, z: centerOffset, id: 'center-3' });
            
            // Outer ring (12 spots in a circle)
            const ringRadius = 16;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
                buildingSpots.push({
                    x: Math.cos(angle) * ringRadius,
                    z: Math.sin(angle) * ringRadius,
                    id: `ring-${i}`
                });
            }

            buildingSpots.forEach((spot, index) => {
                const spotGeometry = new THREE.PlaneGeometry(6, 6);
                const spotMaterial = new THREE.MeshLambertMaterial({
                    color: 0x5a5a4a,
                    transparent: true,
                    opacity: 0.6
                });
                const spotMesh = new THREE.Mesh(spotGeometry, spotMaterial);
                spotMesh.rotation.x = -Math.PI / 2;
                spotMesh.position.set(
                    center.x + spot.x,
                    0.02,
                    center.z + spot.z
                );
                spotMesh.userData = {
                    type: 'buildingSite',
                    siteId: spot.id,
                    owner: label === 'Player Base' ? 'player' : 'enemy',
                    gridX: Math.floor(center.x + spot.x),
                    gridZ: Math.floor(center.z + spot.z),
                    building: null
                };
                scene.add(spotMesh);
                
                // Track building sites
                if (label === 'Player Base') {
                    gameState.playerBuildingSites.push(spotMesh);
                } else {
                    gameState.enemyBuildingSites.push(spotMesh);
                }

                // Add border
                const borderGeometry = new THREE.EdgesGeometry(spotGeometry);
                const borderMaterial = new THREE.LineBasicMaterial({ color: 0x8a8a6a });
                const border = new THREE.LineSegments(borderGeometry, borderMaterial);
                border.rotation.x = -Math.PI / 2;
                border.position.copy(spotMesh.position);
                border.position.y = 0.03;
                scene.add(border);
            });
        }

        function createTree(gridX, gridZ, treeType) {
            let material;
            switch (treeType) {
                case CELL.TREE_HIGH_YIELD:
                    material = treeMaterials.highYield.clone();
                    break;
                case CELL.TREE_ENERGY:
                    material = treeMaterials.energy.clone();
                    break;
                default:
                    material = treeMaterials.normal.clone();
            }

            const sprite = new THREE.Sprite(material);
            
            // Random scale variation
            const scale = CONFIG.TREE_SCALE_MIN + 
                Math.random() * (CONFIG.TREE_SCALE_MAX - CONFIG.TREE_SCALE_MIN);
            
            // Energy trees are slightly larger
            const finalScale = treeType === CELL.TREE_ENERGY ? scale * 1.2 : scale;
            
            sprite.scale.set(finalScale * 3, finalScale * 4.5, 1);
            
            // Position with slight random offset for natural look
            const offsetX = (Math.random() - 0.5) * 0.5;
            const offsetZ = (Math.random() - 0.5) * 0.5;
            
            sprite.position.set(
                gridX * CONFIG.CELL_SIZE + offsetX,
                finalScale * 2.25,
                gridZ * CONFIG.CELL_SIZE + offsetZ
            );

            scene.add(sprite);
            gameState.trees.push({
                sprite,
                gridX,
                gridZ,
                type: treeType
            });
        }

        // ============================================
        // MINIMAP
        // ============================================
        function generateMinimap() {
            const canvas = document.querySelector('#minimap canvas');
            canvas.width = 180;
            canvas.height = 90;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = '#1a2a1a';
            ctx.fillRect(0, 0, 180, 90);

            // Scale factors
            const scaleX = 180 / CONFIG.GRID_WIDTH;
            const scaleY = 90 / CONFIG.GRID_HEIGHT;

            // Draw trees
            for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
                    const cell = gameState.grid[x][z];
                    let color = null;

                    switch (cell) {
                        case CELL.TREE_NORMAL:
                            color = '#4a8c3a';
                            break;
                        case CELL.TREE_HIGH_YIELD:
                            color = '#2d5a1e';
                            break;
                        case CELL.TREE_ENERGY:
                            color = '#9b4dca';
                            break;
                        case CELL.CLEARING_PLAYER:
                            color = '#4a6a3a';
                            break;
                        case CELL.CLEARING_ENEMY:
                            color = '#6a4a3a';
                            break;
                    }

                    if (color) {
                        ctx.fillStyle = color;
                        ctx.fillRect(
                            x * scaleX,
                            z * scaleY,
                            Math.max(1, scaleX),
                            Math.max(1, scaleY)
                        );
                    }
                }
            }
        }

        function updateMinimapCamera() {
            const canvas = document.querySelector('#minimap canvas');
            const ctx = canvas.getContext('2d');
            
            // Redraw base minimap
            generateMinimap();
            
            // Draw camera position
            const scaleX = 180 / CONFIG.GRID_WIDTH;
            const scaleY = 90 / CONFIG.GRID_HEIGHT;
            
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                gameState.camera.target.x * scaleX - 10,
                gameState.camera.target.z * scaleY - 5,
                20,
                10
            );
        }

        // ============================================
        // CAMERA CONTROLS
        // ============================================
        function updateCamera() {
            const cam = gameState.camera;
            const keys = gameState.input.keys;
            const mobile = gameState.input.mobileActions;

            // Pan
            let moveX = 0, moveZ = 0;
            if (keys['KeyW'] || keys['ArrowUp'] || mobile.up) moveZ -= CONFIG.CAMERA_SPEED;
            if (keys['KeyS'] || keys['ArrowDown'] || mobile.down) moveZ += CONFIG.CAMERA_SPEED;
            if (keys['KeyA'] || keys['ArrowLeft'] || mobile.left) moveX -= CONFIG.CAMERA_SPEED;
            if (keys['KeyD'] || keys['ArrowRight'] || mobile.right) moveX += CONFIG.CAMERA_SPEED;

            // Apply rotation to movement
            const cos = Math.cos(cam.angle);
            const sin = Math.sin(cam.angle);
            cam.target.x += moveX * cos - moveZ * sin;
            cam.target.z += moveX * sin + moveZ * cos;

            // Clamp to map bounds
            cam.target.x = Math.max(0, Math.min(CONFIG.GRID_WIDTH, cam.target.x));
            cam.target.z = Math.max(0, Math.min(CONFIG.GRID_HEIGHT, cam.target.z));

            // Rotate
            if (keys['KeyQ'] || mobile.rotleft) cam.angle -= CONFIG.ROTATE_SPEED;
            if (keys['KeyE'] || mobile.rotright) cam.angle += CONFIG.ROTATE_SPEED;

            // Zoom
            if (keys['KeyR'] || mobile.zoomin) cam.distance = Math.max(20, cam.distance - CONFIG.ZOOM_SPEED);
            if (keys['KeyF'] || mobile.zoomout) cam.distance = Math.min(200, cam.distance + CONFIG.ZOOM_SPEED);

            // Calculate camera position
            const pitch = cam.isTopDown ? Math.PI / 2 - 0.01 : cam.pitch;
            
            camera.position.x = cam.target.x + Math.sin(cam.angle) * Math.cos(pitch) * cam.distance;
            camera.position.y = Math.sin(pitch) * cam.distance;
            camera.position.z = cam.target.z + Math.cos(cam.angle) * Math.cos(pitch) * cam.distance;
            
            camera.lookAt(cam.target.x, 0, cam.target.z);

            // Update UI
            document.getElementById('camera-pos').textContent = 
                `${Math.round(cam.target.x)}, ${Math.round(cam.target.z)}`;
            
            updateMinimapCamera();
        }

        function jumpToLocation(x, z) {
            gameState.camera.target.x = x;
            gameState.camera.target.z = z;
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        function initInput() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                gameState.input.keys[e.code] = true;
                
                // Special keys
                if (e.code === 'Space') {
                    gameState.camera.isTopDown = !gameState.camera.isTopDown;
                }
                if (e.code === 'Digit1') {
                    jumpToLocation(CONFIG.GRID_WIDTH / 2, CONFIG.CLEARING_PADDING);
                }
                if (e.code === 'Digit2') {
                    jumpToLocation(CONFIG.GRID_WIDTH / 2, CONFIG.GRID_HEIGHT - CONFIG.CLEARING_PADDING);
                }
            });

            document.addEventListener('keyup', (e) => {
                gameState.input.keys[e.code] = false;
            });

            // Mobile controls
            const mobileButtons = document.querySelectorAll('.mobile-btn');
            mobileButtons.forEach(btn => {
                const action = btn.dataset.action;
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    gameState.input.mobileActions[action] = true;
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    gameState.input.mobileActions[action] = false;
                });
                
                btn.addEventListener('mousedown', () => {
                    gameState.input.mobileActions[action] = true;
                });
                
                btn.addEventListener('mouseup', () => {
                    gameState.input.mobileActions[action] = false;
                });
                
                btn.addEventListener('mouseleave', () => {
                    gameState.input.mobileActions[action] = false;
                });
            });

            // Touch pan on canvas
            let touchStart = null;
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStart = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (touchStart && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - touchStart.x;
                    const deltaY = e.touches[0].clientY - touchStart.y;
                    
                    gameState.camera.target.x -= deltaX * 0.1;
                    gameState.camera.target.z -= deltaY * 0.1;
                    
                    touchStart = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                }
            });

            renderer.domElement.addEventListener('touchend', () => {
                touchStart = null;
            });

            // Mouse wheel zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                gameState.camera.distance += e.deltaY * 0.1;
                gameState.camera.distance = Math.max(20, Math.min(200, gameState.camera.distance));
            });
            
            // Click detection for building sites
            renderer.domElement.addEventListener('click', onCanvasClick);
            renderer.domElement.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 1 && !touchStart) {
                    // This was a tap, not a drag
                    const touch = e.changedTouches[0];
                    onCanvasClick({ clientX: touch.clientX, clientY: touch.clientY });
                }
            });
        }

        // ============================================
        // CLICK DETECTION
        // ============================================
        function onCanvasClick(event) {
            ensureRaycaster();
            
            // Calculate mouse position
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check building sites first
            const siteIntersects = raycaster.intersectObjects(gameState.playerBuildingSites);
            
            if (siteIntersects.length > 0) {
                const clickedSite = siteIntersects[0].object;
                
                if (clickedSite.userData.building) {
                    // Site has a building - show building menu
                    gameState.selectedBuilding = clickedSite.userData.building;
                    gameState.selectedSite = null;
                    if (window.GameUI) {
                        GameUI.showBuildingMenu(clickedSite.userData.building);
                    }
                } else {
                    // Empty site - show build menu
                    gameState.selectedSite = clickedSite;
                    gameState.selectedBuilding = null;
                    if (window.GameUI) {
                        GameUI.showBuildMenu(clickedSite);
                    }
                }
                return;
            }
            
            // Clicked elsewhere - close menus
            gameState.selectedSite = null;
            gameState.selectedBuilding = null;
            if (window.GameUI) {
                GameUI.hideMenus();
            }
        }
        
        function onCanvasTap(event) {
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                onCanvasClick({ clientX: touch.clientX, clientY: touch.clientY });
            }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);
            updateCamera();
            
            // Update units if module loaded
            if (window.GameUnits) {
                GameUnits.update();
            }
            
            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            debug('=== INIT START ===');
            
            try {
                debug('1. Calling initThree()...');
                initThree();
                debug('1. initThree() OK. scene:' + !!scene + ' cam:' + !!camera + ' rend:' + !!renderer);
            } catch(e) {
                debug('ERROR initThree: ' + e.message);
                return;
            }
            
            try {
                debug('2. Calling generateMap()...');
                generateMap();
                debug('2. generateMap() OK. Trees:' + gameState.trees.length);
            } catch(e) {
                debug('ERROR generateMap: ' + e.message);
                return;
            }
            
            try {
                debug('3. Calling initInput()...');
                initInput();
                debug('3. initInput() OK');
            } catch(e) {
                debug('ERROR initInput: ' + e.message);
                return;
            }
            
            // Expose globals for modules AFTER Three.js is initialized
            debug('4. Setting GameEngine globals...');
            window.GameEngine = {
                scene,
                camera,
                renderer,
                gameState,
                CONFIG,
                CELL,
                THREE
            };
            debug('4. GameEngine OK');
            
            // Start at player base
            debug('5. Jump to player base...');
            jumpToLocation(CONFIG.GRID_WIDTH / 2, CONFIG.CLEARING_PADDING);
            
            // Initialize modules after DOM ready
            try {
                debug('6. Init modules...');
                if (window.GameUI) {
                    debug('6a. GameUI.init()...');
                    GameUI.init();
                } else {
                    debug('6a. GameUI NOT FOUND');
                }
                if (window.GameBuildings) {
                    debug('6b. GameBuildings.init()...');
                    GameBuildings.init();
                } else {
                    debug('6b. GameBuildings NOT FOUND');
                }
                if (window.GameUnits) {
                    debug('6c. GameUnits.init()...');
                    GameUnits.init();
                } else {
                    debug('6c. GameUnits NOT FOUND');
                }
                debug('6. Modules done');
            } catch(e) {
                debug('ERROR modules: ' + e.message);
            }
            
            debug('7. Starting animate...');
            animate();
            debug('=== INIT COMPLETE ===');
        }

        // Wait for modules to load
        window.addEventListener('load', init);
        
        // Early check that script is running
        debug('Script loaded, waiting for window.load event...');
        debug('THREE.js available: ' + (typeof THREE !== 'undefined'));
    </script>
    <script src="js/buildings.js" onerror="debug('FAILED to load buildings.js')"></script>
    <script src="js/units.js" onerror="debug('FAILED to load units.js')"></script>
    <script src="js/ui.js" onerror="debug('FAILED to load ui.js')"></script>
</body>
</html>
