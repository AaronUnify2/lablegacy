<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Obelisk: Dream of the Ancients</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            background: #0a0a12;
            font-family: 'Orbitron', sans-serif;
        }
        
        #gameCanvas {
            display: block;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* ============================================
           HUD - Top Left Stats
           ============================================ */
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ffff;
            font-size: 10px;
            text-shadow: 0 0 10px #00ffff, 2px 2px 0 #000;
            line-height: 1.8;
            z-index: 100;
        }
        
        #stats .floor-info {
            color: #ffd700;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        #healthBar {
            width: 150px;
            height: 16px;
            background: #1a1a2e;
            border: 2px solid #00ffff;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
            box-shadow: 0 0 10px rgba(0,255,255,0.3);
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(180deg, #ff6b6b, #c0392b);
            transition: width 0.3s;
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3);
        }
        
        #xpBar {
            width: 150px;
            height: 10px;
            background: #1a1a2e;
            border: 2px solid #9b59b6;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        #xpFill {
            height: 100%;
            background: linear-gradient(180deg, #9b59b6, #8e44ad);
            transition: width 0.3s;
        }
        
        /* ============================================
           Virtual Joystick (Left Side)
           ============================================ */
        #joystickArea {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        
        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(0,255,255,0.1);
            border: 3px solid rgba(0,255,255,0.3);
            border-radius: 50%;
            left: 15px;
            top: 15px;
        }
        
        #joystickThumb {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at 30% 30%, rgba(0,255,255,0.6), rgba(0,255,255,0.2));
            border: 2px solid rgba(0,255,255,0.8);
            border-radius: 50%;
            left: 50px;
            top: 50px;
            transition: none;
        }
        
        /* ============================================
           Action Buttons (Right Side)
           ============================================ */
        #actionButtons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }
        
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.1s;
            text-shadow: 0 0 5px currentColor;
        }
        
        .action-btn .icon {
            font-size: 24px;
            margin-bottom: 2px;
        }
        
        .action-btn:active {
            transform: scale(0.9);
        }
        
        #attackBtn {
            background: radial-gradient(circle at 30% 30%, #9b59b6, #6c3483);
            border: 3px solid #bb8fce;
            box-shadow: 0 0 20px rgba(155,89,182,0.5);
        }
        
        #jumpBtn {
            width: 55px;
            height: 55px;
            background: radial-gradient(circle at 30% 30%, #3498db, #2980b9);
            border: 3px solid #5dade2;
            box-shadow: 0 0 15px rgba(52,152,219,0.5);
            font-size: 8px;
        }
        
        /* Ability Buttons Row */
        #abilityRow {
            position: absolute;
            bottom: 180px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        
        .ability-btn {
            width: 55px;
            height: 55px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #fff;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .ability-btn .icon {
            font-size: 20px;
        }
        
        .ability-btn .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0,0,0,0.7);
            transition: height 0.1s linear;
        }
        
        .ability-btn.on-cooldown {
            opacity: 0.6;
        }
        
        #spreadBtn {
            background: linear-gradient(180deg, #e74c3c, #c0392b);
            border: 2px solid #e74c3c;
        }
        
        #burstBtn {
            background: linear-gradient(180deg, #f39c12, #d68910);
            border: 2px solid #f39c12;
        }
        
        #megaBtn {
            background: linear-gradient(180deg, #1abc9c, #16a085);
            border: 2px solid #1abc9c;
        }
        
        /* ============================================
           View Control Area (Camera Swipe)
           ============================================ */
        #viewArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            pointer-events: auto;
        }
        
        /* ============================================
           Boss Health Bar
           ============================================ */
        #bossHealthBar {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }
        
        #bossHealthBar.active {
            display: flex;
        }
        
        .boss-name {
            color: #ff6b6b;
            font-size: 12px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #ff6b6b, 2px 2px 0 #000;
        }
        
        .boss-bar {
            width: 100%;
            height: 20px;
            background: #1a1a2e;
            border: 3px solid #8b0000;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(139,0,0,0.5);
        }
        
        .boss-fill {
            height: 100%;
            background: linear-gradient(180deg, #e74c3c, #8b0000);
            transition: width 0.2s;
        }
        
        /* ============================================
           Room Indicator
           ============================================ */
        #roomIndicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
            z-index: 100;
        }
        
        /* ============================================
           Minimap
           ============================================ */
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: rgba(10,10,18,0.8);
            border: 2px solid #00ffff;
            border-radius: 5px;
            z-index: 100;
        }
        
        .minimap-room {
            position: absolute;
            background: #333;
            border: 1px solid #00ffff;
        }
        
        .minimap-room.current {
            background: #00ffff;
        }
        
        .minimap-room.visited {
            background: #1a4a4a;
        }
        
        .minimap-player {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* ============================================
           Menu Button
           ============================================ */
        #menuBtn {
            position: absolute;
            top: 120px;
            right: 10px;
            width: 50px;
            height: 50px;
            background: linear-gradient(180deg, rgba(0,255,255,0.3), rgba(0,100,150,0.3));
            border: 2px solid #00ffff;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #00ffff;
            pointer-events: auto;
            cursor: pointer;
            z-index: 100;
        }
        
        #menuBtn .btn-label {
            font-size: 6px;
            margin-top: 2px;
        }
        
        /* ============================================
           Upgrade Menu
           ============================================ */
        #upgradeMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10,10,18,0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
            pointer-events: auto;
        }
        
        #menuContent {
            background: linear-gradient(180deg, #1a1a2e, #0a0a12);
            border: 3px solid #00ffff;
            border-radius: 16px;
            padding: 20px;
            max-width: 380px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0,255,255,0.3);
        }
        
        #menuContent h2 {
            color: #00ffff;
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .menu-section {
            margin-bottom: 20px;
        }
        
        .menu-section h3 {
            color: #9b59b6;
            font-size: 11px;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        
        .upgrade-item {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            gap: 10px;
        }
        
        .upgrade-item.maxed {
            border-color: #27ae60;
            opacity: 0.7;
        }
        
        .upgrade-icon {
            font-size: 24px;
            width: 36px;
            text-align: center;
        }
        
        .upgrade-info {
            flex: 1;
        }
        
        .upgrade-name {
            color: #fff;
            font-size: 9px;
            margin-bottom: 2px;
        }
        
        .upgrade-desc {
            color: #888;
            font-size: 7px;
            margin-bottom: 4px;
        }
        
        .upgrade-level {
            color: #00ffff;
            font-size: 7px;
        }
        
        .upgrade-btn {
            background: linear-gradient(180deg, #9b59b6, #6c3483);
            border: 2px solid #bb8fce;
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            cursor: pointer;
            pointer-events: auto;
            min-width: 60px;
        }
        
        .upgrade-btn:disabled {
            background: #333;
            border-color: #444;
            color: #666;
            cursor: not-allowed;
        }
        
        #closeMenu {
            width: 100%;
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(180deg, #c0392b, #96281b);
            border: 2px solid #e74c3c;
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        /* ============================================
           Dialogue Box
           ============================================ */
        #dialogueBox {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10,10,18,0.95);
            border: 3px solid #ffd700;
            border-radius: 12px;
            padding: 15px 25px;
            max-width: 350px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 200;
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
            pointer-events: auto;
        }
        
        #dialogueBox.active {
            display: flex;
            animation: dialoguePop 0.3s ease-out;
        }
        
        @keyframes dialoguePop {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        
        .dialogue-speaker {
            color: #ffd700;
            font-size: 10px;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #ffd700;
        }
        
        .dialogue-text {
            color: #fff;
            font-size: 9px;
            text-align: center;
            line-height: 1.6;
        }
        
        .dialogue-continue {
            margin-top: 12px;
            padding: 8px 20px;
            background: linear-gradient(180deg, #f39c12, #d68910);
            border: 2px solid #ffd700;
            border-radius: 6px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        /* ============================================
           Damage Flash
           ============================================ */
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,0,0,0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        
        /* ============================================
           Level Up Notification
           ============================================ */
        #levelUp {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 20px;
            text-shadow: 0 0 20px #ffd700, 0 0 40px #ff8c00;
            opacity: 0;
            pointer-events: none;
        }
        
        @keyframes levelUpAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) translateY(-50px); }
        }
        
        /* ============================================
           Game Over Screen
           ============================================ */
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10,10,18,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 1000;
        }
        
        #gameOver h1 {
            color: #c0392b;
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #c0392b;
        }
        
        #gameOver p {
            font-size: 11px;
            margin: 8px 0;
            color: #00ffff;
        }
        
        #restartBtn {
            margin-top: 30px;
            padding: 15px 30px;
            background: linear-gradient(180deg, #00ffff, #008888);
            border: none;
            border-radius: 8px;
            color: #0a0a12;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
        }
        
        /* ============================================
           Town/Dungeon Transition
           ============================================ */
        #transitionScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a12;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 600;
        }
        
        #transitionScreen.active {
            display: flex;
        }
        
        #transitionScreen h2 {
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 20px;
        }
        
        .loading-bar {
            width: 200px;
            height: 10px;
            background: #1a1a2e;
            border: 2px solid #00ffff;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .loading-fill {
            height: 100%;
            background: #00ffff;
            width: 0%;
            transition: width 0.3s;
        }
        
        /* ============================================
           Town Interaction Prompts
           ============================================ */
        #interactPrompt {
            position: absolute;
            bottom: 250px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10,10,18,0.8);
            border: 2px solid #00ffff;
            border-radius: 8px;
            padding: 10px 20px;
            color: #00ffff;
            font-size: 10px;
            display: none;
            z-index: 150;
        }
        
        #interactPrompt.active {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <!-- HUD Stats -->
        <div id="stats">
            <div class="floor-info">TOWN</div>
            <div>HP: <span id="healthText">100/100</span></div>
            <div id="healthBar"><div id="healthFill"></div></div>
            <div style="margin-top:8px;">XP: <span id="xpText">0</span></div>
            <div id="xpBar"><div id="xpFill"></div></div>
        </div>
        
        <!-- Room Indicator -->
        <div id="roomIndicator">CENTER HALL</div>
        
        <!-- Minimap -->
        <div id="minimap"></div>
        
        <!-- Menu Button -->
        <div id="menuBtn">
            <span>‚ò∞</span>
            <span class="btn-label">MENU</span>
        </div>
        
        <!-- Boss Health Bar -->
        <div id="bossHealthBar">
            <div class="boss-name">PILLAR GUARDIAN</div>
            <div class="boss-bar"><div class="boss-fill" id="bossFill"></div></div>
        </div>
        
        <!-- Virtual Joystick -->
        <div id="joystickArea">
            <div id="joystickBase"></div>
            <div id="joystickThumb"></div>
        </div>
        
        <!-- View Control Area -->
        <div id="viewArea"></div>
        
        <!-- Ability Buttons -->
        <div id="abilityRow">
            <div class="ability-btn" id="spreadBtn">
                <span class="icon">‚óÜ</span>
                <span>SPREAD</span>
                <div class="cooldown-overlay" id="spreadCooldown"></div>
            </div>
            <div class="ability-btn" id="burstBtn">
                <span class="icon">‚ö°</span>
                <span>BURST</span>
                <div class="cooldown-overlay" id="burstCooldown"></div>
            </div>
            <div class="ability-btn" id="megaBtn">
                <span class="icon">‚óè</span>
                <span>MEGA</span>
                <div class="cooldown-overlay" id="megaCooldown"></div>
            </div>
        </div>
        
        <!-- Action Buttons -->
        <div id="actionButtons">
            <div class="action-btn" id="jumpBtn">
                <span class="icon">‚Üë</span>
                <span>JUMP</span>
            </div>
            <div class="action-btn" id="attackBtn">
                <span class="icon">‚ú¶</span>
                <span>ATTACK</span>
            </div>
        </div>
        
        <!-- Dialogue Box -->
        <div id="dialogueBox">
            <div class="dialogue-speaker" id="dialogueSpeaker">THE GUIDE</div>
            <div class="dialogue-text" id="dialogueText">Welcome to the Obelisk, traveler...</div>
            <button class="dialogue-continue" id="dialogueContinue">CONTINUE</button>
        </div>
        
        <!-- Interact Prompt -->
        <div id="interactPrompt">Press ATTACK to interact</div>
        
        <!-- Damage Flash -->
        <div id="damageFlash"></div>
        
        <!-- Level Up -->
        <div id="levelUp">LEVEL UP!</div>
    </div>
    
    <!-- Upgrade Menu -->
    <div id="upgradeMenu">
        <div id="menuContent">
            <h2>‚öô UPGRADES</h2>
            
            <div class="menu-section">
                <h3>BASE STATS</h3>
                <div class="upgrade-item" data-upgrade="maxHealth">
                    <div class="upgrade-icon">‚ù§</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">MAX HEALTH</div>
                        <div class="upgrade-desc">+20 max HP per level</div>
                        <div class="upgrade-level">Level: <span>0</span>/5</div>
                    </div>
                    <button class="upgrade-btn">100 XP</button>
                </div>
                <div class="upgrade-item" data-upgrade="baseDamage">
                    <div class="upgrade-icon">‚öî</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">BASE DAMAGE</div>
                        <div class="upgrade-desc">+8 damage per level</div>
                        <div class="upgrade-level">Level: <span>0</span>/5</div>
                    </div>
                    <button class="upgrade-btn">100 XP</button>
                </div>
                <div class="upgrade-item" data-upgrade="fireRate">
                    <div class="upgrade-icon">üî•</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">FIRE RATE</div>
                        <div class="upgrade-desc">Faster attacks</div>
                        <div class="upgrade-level">Level: <span>0</span>/5</div>
                    </div>
                    <button class="upgrade-btn">100 XP</button>
                </div>
                <div class="upgrade-item" data-upgrade="aimAssist">
                    <div class="upgrade-icon">‚óé</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">AIM ASSIST</div>
                        <div class="upgrade-desc">Projectiles curve toward enemies</div>
                        <div class="upgrade-level">Level: <span>0</span>/5</div>
                    </div>
                    <button class="upgrade-btn">100 XP</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>ABILITIES</h3>
                <div class="upgrade-item" data-upgrade="spreadCooldown">
                    <div class="upgrade-icon">‚óÜ</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">SPREAD COOLDOWN</div>
                        <div class="upgrade-desc">Reduce cooldown by 0.6s</div>
                        <div class="upgrade-level">Level: <span>0</span>/5</div>
                    </div>
                    <button class="upgrade-btn">75 XP</button>
                </div>
                <div class="upgrade-item" data-upgrade="burstDuration">
                    <div class="upgrade-icon">‚ö°</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">BURST DURATION</div>
                        <div class="upgrade-desc">+0.5s burst time</div>
                        <div class="upgrade-level">Level: <span>0</span>/5</div>
                    </div>
                    <button class="upgrade-btn">75 XP</button>
                </div>
                <div class="upgrade-item" data-upgrade="megaDamage">
                    <div class="upgrade-icon">‚óè</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">MEGA DAMAGE</div>
                        <div class="upgrade-desc">+100% mega ball damage</div>
                        <div class="upgrade-level">Level: <span>0</span>/5</div>
                    </div>
                    <button class="upgrade-btn">75 XP</button>
                </div>
            </div>
            
            <button id="closeMenu">CLOSE</button>
        </div>
    </div>
    
    <!-- Transition Screen -->
    <div id="transitionScreen">
        <h2 id="transitionText">ENTERING FLOOR 1</h2>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
    </div>
    
    <!-- Game Over -->
    <div id="gameOver">
        <h1>DEFEATED</h1>
        <p>Floor Reached: <span id="finalFloor">1</span></p>
        <p>Enemies Slain: <span id="finalKills">0</span></p>
        <p>XP Earned: <span id="finalXP">0</span></p>
        <button id="restartBtn">RETURN TO TOWN</button>
    </div>

    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            // Rendering
            fogDensity: 0.05,
            
            // Player
            playerSpeed: 0.12,
            playerJumpForce: 0.25,
            playerMaxHealth: 100,
            playerBaseDamage: 10,
            playerBaseFireRate: 1000, // ms between shots
            
            // Projectiles
            projectileSpeed: 0.5,
            projectileLife: 120, // frames
            
            // Abilities
            spreadCooldown: 8000, // 8 seconds
            burstCooldown: 15000, // 15 seconds
            megaCooldown: 20000, // 20 seconds
            burstDuration: 3000, // 3 seconds
            
            // Room dimensions
            roomSize: 40,
            hallwayWidth: 8,
            hallwayLength: 15,
            wallHeight: 6,
            
            // Enemies
            enemySpawnDelay: 500,
            maxEnemiesPerRoom: 8
        };

        // ============================================
        // GAME STATE
        // ============================================
        const GAME_STATE = {
            LOADING: 'loading',
            TOWN: 'town',
            DUNGEON: 'dungeon',
            PAUSED: 'paused',
            GAME_OVER: 'gameOver'
        };

        const gameState = {
            currentState: GAME_STATE.LOADING,
            currentFloor: 0, // 0 = town
            currentRoom: 'center',
            
            player: {
                position: new THREE.Vector3(0, 0, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: 0,
                health: CONFIG.playerMaxHealth,
                maxHealth: CONFIG.playerMaxHealth,
                isGrounded: true,
                isJumping: false
            },
            
            // Progression
            xp: 0,
            totalXPEarned: 0,
            kills: 0,
            maxFloorReached: 1,
            
            // Upgrades (matching dev guide)
            upgrades: {
                maxHealth: { level: 0, maxLevel: 5, baseCost: 100, costMult: 1.5 },
                baseDamage: { level: 0, maxLevel: 5, baseCost: 100, costMult: 1.5 },
                fireRate: { level: 0, maxLevel: 5, baseCost: 100, costMult: 1.5 },
                aimAssist: { level: 0, maxLevel: 5, baseCost: 100, costMult: 1.5 },
                spreadCooldown: { level: 0, maxLevel: 5, baseCost: 75, costMult: 1.4 },
                burstDuration: { level: 0, maxLevel: 5, baseCost: 75, costMult: 1.4 },
                megaDamage: { level: 0, maxLevel: 5, baseCost: 75, costMult: 1.4 }
            },
            
            // Ability cooldowns
            abilities: {
                spread: { cooldown: 0, maxCooldown: CONFIG.spreadCooldown },
                burst: { cooldown: 0, maxCooldown: CONFIG.burstCooldown, active: false, duration: 0 },
                mega: { cooldown: 0, maxCooldown: CONFIG.megaCooldown }
            },
            
            // Attack cooldown
            lastAttackTime: 0,
            
            // Collections
            enemies: [],
            projectiles: [],
            xpOrbs: [],
            npcs: [],
            bosses: [],
            
            // Room management
            rooms: new Map(),
            visitedRooms: new Set(),
            clearedRooms: new Set(),
            
            // UI State
            menuOpen: false,
            dialogueActive: false,
            dialogueQueue: [],
            nearbyNPC: null,
            
            // Camera
            cameraZoom: 1
        };

        // Input state
        const controls = {
            moveX: 0,
            moveZ: 0,
            jump: false,
            attack: false
        };

        // ============================================
        // THREE.JS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas, 
            antialias: false,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x0a0a12);

        const scene = new THREE.Scene();

        // Fog for atmosphere (Machine Tomb theme)
        scene.fog = new THREE.FogExp2(0x0a0a12, CONFIG.fogDensity);

        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            100
        );
        camera.position.set(0, 8, 12);
        camera.lookAt(0, 2, 0);

        // ============================================
        // LIGHTING SETUP
        // ============================================
        // Dim ambient light
        const ambientLight = new THREE.AmbientLight(0x111122, 0.3);
        scene.add(ambientLight);

        // Subtle directional light from above
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.2);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);

        // Dynamic spotlights (will be added per room)
        const spotlights = [];

        function createSpotlight(color, x, y, z, targetX, targetY, targetZ) {
            const spot = new THREE.SpotLight(color, 1.5);
            spot.position.set(x, y, z);
            spot.angle = Math.PI / 6;
            spot.penumbra = 0.5;
            spot.decay = 2;
            spot.distance = 30;
            
            const target = new THREE.Object3D();
            target.position.set(targetX, targetY, targetZ);
            scene.add(target);
            spot.target = target;
            
            scene.add(spot);
            spotlights.push(spot);
            return spot;
        }

        // ============================================
        // TEXTURE GENERATORS (Canvas-based)
        // ============================================
        function createPixelTexture(width, height, drawFunc) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            drawFunc(ctx, width, height);
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // Floor texture - metal panels with cyan glow lines
        function createFloorTexture() {
            return createPixelTexture(64, 64, (ctx, w, h) => {
                // Base dark metal
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, w, h);
                
                // Grid lines
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.3;
                
                // Horizontal lines
                for (let y = 0; y < h; y += 16) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
                
                // Vertical lines
                for (let x = 0; x < w; x += 16) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1;
                
                // Metal panel details
                ctx.fillStyle = '#2a2a3a';
                for (let i = 0; i < 4; i++) {
                    const px = (i % 2) * 32 + 4;
                    const py = Math.floor(i / 2) * 32 + 4;
                    ctx.fillRect(px, py, 24, 24);
                }
            });
        }

        // Wall texture - dark metal with warning glyphs
        function createWallTexture() {
            return createPixelTexture(64, 64, (ctx, w, h) => {
                // Base
                ctx.fillStyle = '#2a2a3a';
                ctx.fillRect(0, 0, w, h);
                
                // Vertical panels
                ctx.fillStyle = '#3a3a4a';
                ctx.fillRect(4, 0, 24, h);
                ctx.fillRect(36, 0, 24, h);
                
                // Glow lines
                ctx.fillStyle = '#00ffff';
                ctx.globalAlpha = 0.5;
                ctx.fillRect(0, 30, w, 2);
                ctx.fillRect(30, 0, 2, h);
                ctx.globalAlpha = 1;
                
                // Rivet details
                ctx.fillStyle = '#1a1a2e';
                const rivets = [[8, 8], [56, 8], [8, 56], [56, 56]];
                rivets.forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            });
        }

        // Player mage texture
        function createPlayerTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Robe body
                ctx.fillStyle = '#1a1a4a';
                ctx.fillRect(8, 16, 16, 26);
                ctx.fillRect(6, 38, 20, 10);
                
                // Robe trim (cyan glow)
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(8, 16, 16, 2);
                ctx.fillRect(6, 38, 20, 2);
                ctx.fillRect(8, 16, 2, 26);
                ctx.fillRect(22, 16, 2, 26);
                
                // Hood/Head area (shadowed)
                ctx.fillStyle = '#0a0a2a';
                ctx.fillRect(10, 4, 12, 14);
                
                // Hood outline
                ctx.fillStyle = '#1a1a4a';
                ctx.fillRect(8, 2, 16, 4);
                ctx.fillRect(6, 6, 4, 10);
                ctx.fillRect(22, 6, 4, 10);
                
                // Glowing eyes (subtle)
                ctx.fillStyle = '#00ffff';
                ctx.globalAlpha = 0.7;
                ctx.fillRect(12, 10, 3, 2);
                ctx.fillRect(17, 10, 3, 2);
                ctx.globalAlpha = 1;
                
                // Hands (glowing when casting)
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(4, 26, 4, 4);
                ctx.fillRect(24, 26, 4, 4);
            });
        }

        // Drone enemy texture
        function createDroneTexture() {
            return createPixelTexture(32, 32, (ctx, w, h) => {
                // Body - floating sphere
                ctx.fillStyle = '#3a3a4a';
                ctx.beginPath();
                ctx.arc(16, 16, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Metal panels
                ctx.fillStyle = '#4a4a5a';
                ctx.beginPath();
                ctx.arc(16, 14, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye/sensor
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(16, 14, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner eye glow
                ctx.fillStyle = '#ff6666';
                ctx.beginPath();
                ctx.arc(15, 13, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Antenna
                ctx.fillStyle = '#3a3a4a';
                ctx.fillRect(14, 2, 4, 6);
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(15, 2, 2, 2);
            });
        }

        // Walker enemy texture
        function createWalkerTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Body - humanoid machine
                ctx.fillStyle = '#3a3a4a';
                ctx.fillRect(10, 12, 12, 20);
                
                // Head
                ctx.fillStyle = '#4a4a5a';
                ctx.fillRect(12, 4, 8, 10);
                
                // Eyes
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(13, 7, 3, 3);
                ctx.fillRect(18, 7, 3, 3);
                
                // Arms
                ctx.fillStyle = '#3a3a4a';
                ctx.fillRect(4, 14, 6, 16);
                ctx.fillRect(22, 14, 6, 16);
                
                // Legs
                ctx.fillRect(10, 32, 5, 16);
                ctx.fillRect(17, 32, 5, 16);
                
                // Glowing joints
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(6, 20, 2, 2);
                ctx.fillRect(24, 20, 2, 2);
                ctx.fillRect(12, 38, 2, 2);
                ctx.fillRect(18, 38, 2, 2);
            });
        }

        // Turret enemy texture
        function createTurretTexture() {
            return createPixelTexture(32, 32, (ctx, w, h) => {
                // Base
                ctx.fillStyle = '#2a2a3a';
                ctx.fillRect(6, 22, 20, 10);
                
                // Barrel housing
                ctx.fillStyle = '#3a3a4a';
                ctx.fillRect(10, 10, 12, 14);
                
                // Barrel
                ctx.fillStyle = '#4a4a5a';
                ctx.fillRect(13, 4, 6, 10);
                
                // Muzzle glow
                ctx.fillStyle = '#ff6600';
                ctx.fillRect(14, 4, 4, 2);
                
                // Sensor eye
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(16, 18, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Base lights
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(8, 28, 2, 2);
                ctx.fillRect(22, 28, 2, 2);
            });
        }

        // Wisp enemy texture
        function createWispTexture() {
            return createPixelTexture(24, 24, (ctx, w, h) => {
                // Outer glow
                const gradient = ctx.createRadialGradient(12, 12, 0, 12, 12, 12);
                gradient.addColorStop(0, 'rgba(155, 89, 182, 1)');
                gradient.addColorStop(0.5, 'rgba(155, 89, 182, 0.5)');
                gradient.addColorStop(1, 'rgba(155, 89, 182, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, w, h);
                
                // Core
                ctx.fillStyle = '#bb8fce';
                ctx.beginPath();
                ctx.arc(12, 12, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Bright center
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(12, 12, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Magic projectile texture
        function createProjectileTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                // Outer glow
                const gradient = ctx.createRadialGradient(8, 8, 0, 8, 8, 8);
                gradient.addColorStop(0, '#00ffff');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.5)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, w, h);
                
                // Core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(8, 8, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Mega ball projectile texture
        function createMegaBallTexture() {
            return createPixelTexture(32, 32, (ctx, w, h) => {
                // Outer glow
                const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                gradient.addColorStop(0, '#1abc9c');
                gradient.addColorStop(0.3, '#16a085');
                gradient.addColorStop(0.6, 'rgba(26, 188, 156, 0.5)');
                gradient.addColorStop(1, 'rgba(26, 188, 156, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, w, h);
                
                // Core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(16, 16, 6, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // XP orb texture
        function createXPOrbTexture() {
            return createPixelTexture(16, 16, (ctx, w, h) => {
                ctx.fillStyle = '#9b59b6';
                ctx.beginPath();
                ctx.arc(8, 8, 7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#bb8fce';
                ctx.beginPath();
                ctx.arc(8, 8, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.fillRect(5, 5, 3, 3);
            });
        }

        // NPC - The Guide texture
        function createGuideTexture() {
            return createPixelTexture(32, 48, (ctx, w, h) => {
                // Robe
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(8, 16, 16, 26);
                ctx.fillRect(6, 38, 20, 10);
                
                // Hood
                ctx.fillStyle = '#6b3510';
                ctx.fillRect(10, 4, 12, 14);
                ctx.fillRect(8, 2, 16, 4);
                
                // Face (warm tone)
                ctx.fillStyle = '#deb887';
                ctx.fillRect(12, 8, 8, 8);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(13, 10, 2, 2);
                ctx.fillRect(17, 10, 2, 2);
                
                // Staff
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(26, 8, 3, 40);
                
                // Staff crystal
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(24, 4, 7, 6);
            });
        }

        // Door/Gate texture
        function createDoorTexture(isOpen = false) {
            return createPixelTexture(64, 64, (ctx, w, h) => {
                if (isOpen) {
                    // Open doorway - dark passage
                    ctx.fillStyle = '#050510';
                    ctx.fillRect(8, 0, 48, h);
                    
                    // Frame
                    ctx.fillStyle = '#3a3a4a';
                    ctx.fillRect(0, 0, 10, h);
                    ctx.fillRect(54, 0, 10, h);
                    
                    // Glow
                    ctx.fillStyle = '#00ffff';
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(8, 0, 2, h);
                    ctx.fillRect(54, 0, 2, h);
                } else {
                    // Closed door
                    ctx.fillStyle = '#3a3a4a';
                    ctx.fillRect(0, 0, w, h);
                    
                    // Panel lines
                    ctx.fillStyle = '#2a2a3a';
                    ctx.fillRect(30, 0, 4, h);
                    ctx.fillRect(0, 30, w, 4);
                    
                    // Lock indicator
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(32, 32, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // ============================================
        // CREATE TEXTURES
        // ============================================
        const floorTexture = createFloorTexture();
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(4, 4);

        const wallTexture = createWallTexture();
        wallTexture.wrapS = THREE.RepeatWrapping;
        wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set(4, 1);

        const playerTexture = createPlayerTexture();
        const projectileTexture = createProjectileTexture();
        const megaBallTexture = createMegaBallTexture();
        const xpOrbTexture = createXPOrbTexture();

        // Enemy textures
        const enemyTextures = {
            drone: createDroneTexture(),
            walker: createWalkerTexture(),
            turret: createTurretTexture(),
            wisp: createWispTexture()
        };

        // NPC textures
        const npcTextures = {
            guide: createGuideTexture()
        };

        // ============================================
        // PLAYER CREATION
        // ============================================
        const playerGroup = new THREE.Group();

        const playerMaterial = new THREE.SpriteMaterial({ 
            map: playerTexture, 
            transparent: true 
        });
        const playerSprite = new THREE.Sprite(playerMaterial);
        playerSprite.scale.set(2, 3, 1);
        playerSprite.position.y = 1.5;
        playerGroup.add(playerSprite);

        scene.add(playerGroup);

        // ============================================
        // GROUND PLANE (follows player)
        // ============================================
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshBasicMaterial({ 
            map: floorTexture,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        scene.add(ground);

        // ============================================
        // ROOM SYSTEM
        // ============================================
        const ROOM_TYPES = {
            CENTER: 'center',
            NORTH: 'north',
            SOUTH: 'south',
            EAST: 'east',
            WEST: 'west'
        };

        // Room layout (cross pattern as per dev guide)
        const roomLayout = {
            center: { x: 0, z: 0, connections: ['north', 'south', 'east', 'west'] },
            north: { x: 0, z: -CONFIG.roomSize - CONFIG.hallwayLength, connections: ['center'] },
            south: { x: 0, z: CONFIG.roomSize + CONFIG.hallwayLength, connections: ['center'] },
            east: { x: CONFIG.roomSize + CONFIG.hallwayLength, z: 0, connections: ['center'] },
            west: { x: -CONFIG.roomSize - CONFIG.hallwayLength, z: 0, connections: ['center'] }
        };

        function createRoom(roomId, floor = 1) {
            const layout = roomLayout[roomId];
            const roomGroup = new THREE.Group();
            roomGroup.position.set(layout.x, 0, layout.z);
            
            const halfSize = CONFIG.roomSize / 2;
            const wallMat = new THREE.MeshBasicMaterial({ 
                map: wallTexture,
                side: THREE.DoubleSide
            });
            
            // Create walls based on connections
            const hasNorth = layout.connections.includes('north') || (roomId === 'north');
            const hasSouth = layout.connections.includes('south') || (roomId === 'south');
            const hasEast = layout.connections.includes('east') || (roomId === 'east');
            const hasWest = layout.connections.includes('west') || (roomId === 'west');
            
            // North wall
            if (roomId !== 'south' && roomId !== 'center') {
                createWall(roomGroup, 0, -halfSize, CONFIG.roomSize, 'z', wallMat);
            } else if (roomId === 'center') {
                // Wall with opening for north
                createWallWithOpening(roomGroup, 0, -halfSize, CONFIG.roomSize, 'z', wallMat);
            }
            
            // South wall
            if (roomId !== 'north' && roomId !== 'center') {
                createWall(roomGroup, 0, halfSize, CONFIG.roomSize, 'z', wallMat);
            } else if (roomId === 'center') {
                createWallWithOpening(roomGroup, 0, halfSize, CONFIG.roomSize, 'z', wallMat);
            }
            
            // East wall
            if (roomId !== 'west' && roomId !== 'center') {
                createWall(roomGroup, halfSize, 0, CONFIG.roomSize, 'x', wallMat);
            } else if (roomId === 'center') {
                createWallWithOpening(roomGroup, halfSize, 0, CONFIG.roomSize, 'x', wallMat);
            }
            
            // West wall
            if (roomId !== 'east' && roomId !== 'center') {
                createWall(roomGroup, -halfSize, 0, CONFIG.roomSize, 'x', wallMat);
            } else if (roomId === 'center') {
                createWallWithOpening(roomGroup, -halfSize, 0, CONFIG.roomSize, 'x', wallMat);
            }
            
            // Add room lighting
            const themeColors = getFloorThemeColors(floor);
            const spot = new THREE.PointLight(themeColors.spotlight, 1, 30);
            spot.position.set(0, 5, 0);
            roomGroup.add(spot);
            
            scene.add(roomGroup);
            gameState.rooms.set(roomId, roomGroup);
            
            return roomGroup;
        }

        function createWall(parent, x, z, length, axis, material) {
            const wallGeo = new THREE.BoxGeometry(
                axis === 'z' ? length : 1,
                CONFIG.wallHeight,
                axis === 'x' ? length : 1
            );
            const wall = new THREE.Mesh(wallGeo, material);
            wall.position.set(x, CONFIG.wallHeight / 2, z);
            parent.add(wall);
        }

        function createWallWithOpening(parent, x, z, length, axis, material) {
            const openingSize = CONFIG.hallwayWidth;
            const sideLength = (length - openingSize) / 2;
            
            // Left/Front segment
            const seg1Geo = new THREE.BoxGeometry(
                axis === 'z' ? sideLength : 1,
                CONFIG.wallHeight,
                axis === 'x' ? sideLength : 1
            );
            const seg1 = new THREE.Mesh(seg1Geo, material);
            if (axis === 'z') {
                seg1.position.set(x - (length / 2) + (sideLength / 2), CONFIG.wallHeight / 2, z);
            } else {
                seg1.position.set(x, CONFIG.wallHeight / 2, z - (length / 2) + (sideLength / 2));
            }
            parent.add(seg1);
            
            // Right/Back segment
            const seg2 = new THREE.Mesh(seg1Geo, material);
            if (axis === 'z') {
                seg2.position.set(x + (length / 2) - (sideLength / 2), CONFIG.wallHeight / 2, z);
            } else {
                seg2.position.set(x, CONFIG.wallHeight / 2, z + (length / 2) - (sideLength / 2));
            }
            parent.add(seg2);
        }

        // Get floor theme colors based on floor number
        function getFloorThemeColors(floor) {
            if (floor <= 3) {
                // Machine Tomb
                return {
                    fog: 0x0a0a12,
                    spotlight: 0x00ffff,
                    accent: 0x0066aa
                };
            } else if (floor <= 6) {
                // Corruption
                return {
                    fog: 0x0a0812,
                    spotlight: 0x9900ff,
                    accent: 0xff00aa
                };
            } else if (floor <= 9) {
                // Dream Bleeds Through
                return {
                    fog: 0x12100a,
                    spotlight: 0xffaa00,
                    accent: 0xffcc44
                };
            } else {
                // The Source
                return {
                    fog: 0x1a1812,
                    spotlight: 0xffffff,
                    accent: 0xffdd66
                };
            }
        }

        // ============================================
        // ENEMY SYSTEM
        // ============================================
        const enemyTypes = {
            drone: {
                name: 'Maintenance Drone',
                texture: 'drone',
                scale: [2.5, 2.5],
                speed: 0.04,
                health: 20,
                damage: 8,
                xp: 15,
                behavior: 'hover' // Hovers and shoots
            },
            walker: {
                name: 'Patrol Walker',
                texture: 'walker',
                scale: [2.5, 4],
                speed: 0.035,
                health: 40,
                damage: 15,
                xp: 25,
                behavior: 'charge' // Charges at player
            },
            turret: {
                name: 'Defense Turret',
                texture: 'turret',
                scale: [2.5, 2.5],
                speed: 0,
                health: 30,
                damage: 5,
                xp: 20,
                behavior: 'stationary' // Doesn't move, shoots
            },
            wisp: {
                name: 'Dream Wisp',
                texture: 'wisp',
                scale: [2, 2],
                speed: 0.06,
                health: 15,
                damage: 30,
                xp: 30,
                behavior: 'suicide' // Fast, explodes near player
            }
        };

        function spawnEnemy(type, x, z, floorLevel = 1) {
            const enemyType = enemyTypes[type];
            if (!enemyType) return null;
            
            const texture = enemyTextures[enemyType.texture];
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true 
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(enemyType.scale[0], enemyType.scale[1], 1);
            sprite.position.set(x, enemyType.scale[1] / 2, z);
            
            // Scale stats based on floor
            const floorMult = 1 + (floorLevel - 1) * 0.15;
            
            const enemy = {
                sprite,
                type: enemyType,
                typeName: type,
                health: enemyType.health * floorMult,
                maxHealth: enemyType.health * floorMult,
                damage: enemyType.damage * floorMult,
                xp: Math.floor(enemyType.xp * floorMult),
                attackCooldown: 0,
                hitFlash: 0,
                shootCooldown: 0
            };
            
            scene.add(sprite);
            gameState.enemies.push(enemy);
            
            return enemy;
        }

        function spawnRoomEnemies(roomId, floor) {
            const layout = roomLayout[roomId];
            const roomX = layout.x;
            const roomZ = layout.z;
            const halfSize = CONFIG.roomSize / 2 - 5;
            
            // Determine enemy count and types based on floor and room
            let enemyCount = 2 + Math.floor(floor / 2);
            enemyCount = Math.min(enemyCount, CONFIG.maxEnemiesPerRoom);
            
            // Available enemy types based on floor
            let availableTypes = ['drone'];
            if (floor >= 2) availableTypes.push('walker');
            if (floor >= 3) availableTypes.push('turret');
            if (floor >= 4) availableTypes.push('wisp');
            
            for (let i = 0; i < enemyCount; i++) {
                const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                const ex = roomX + (Math.random() - 0.5) * halfSize * 2;
                const ez = roomZ + (Math.random() - 0.5) * halfSize * 2;
                spawnEnemy(type, ex, ez, floor);
            }
        }

        function updateEnemies() {
            if (gameState.dialogueActive) return;
            
            const playerPos = gameState.player.position;
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                const dx = playerPos.x - enemy.sprite.position.x;
                const dz = playerPos.z - enemy.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                // Behavior based on type
                switch (enemy.type.behavior) {
                    case 'hover':
                    case 'charge':
                        // Move toward player
                        if (dist > 2 && enemy.type.speed > 0) {
                            enemy.sprite.position.x += (dx / dist) * enemy.type.speed;
                            enemy.sprite.position.z += (dz / dist) * enemy.type.speed;
                        } else if (dist <= 2 && enemy.attackCooldown <= 0) {
                            // Melee attack
                            takeDamage(enemy.damage);
                            enemy.attackCooldown = 60;
                        }
                        break;
                        
                    case 'stationary':
                        // Turret - shoots at player
                        if (enemy.shootCooldown <= 0 && dist < 25) {
                            // Could spawn enemy projectile here
                            enemy.shootCooldown = 90;
                        }
                        break;
                        
                    case 'suicide':
                        // Wisp - fast approach, explodes
                        if (dist > 1.5) {
                            enemy.sprite.position.x += (dx / dist) * enemy.type.speed;
                            enemy.sprite.position.z += (dz / dist) * enemy.type.speed;
                        } else {
                            // Explode
                            takeDamage(enemy.damage);
                            destroyEnemy(i, false); // No XP from suicide
                        }
                        break;
                }
                
                enemy.attackCooldown = Math.max(0, enemy.attackCooldown - 1);
                enemy.shootCooldown = Math.max(0, enemy.shootCooldown - 1);
                
                // Hit flash effect
                if (enemy.hitFlash > 0) {
                    enemy.hitFlash--;
                    enemy.sprite.material.color.setHex(0xffffff);
                } else {
                    enemy.sprite.material.color.setHex(0xffffff);
                }
                
                // Check if dead
                if (enemy.health <= 0) {
                    destroyEnemy(i, true);
                }
            }
        }

        function destroyEnemy(index, dropXP) {
            const enemy = gameState.enemies[index];
            if (dropXP) {
                spawnXPOrb(enemy.sprite.position.clone(), enemy.xp);
                gameState.kills++;
            }
            scene.remove(enemy.sprite);
            gameState.enemies.splice(index, 1);
        }

        // ============================================
        // PROJECTILE SYSTEM
        // ============================================
        function shootProjectile() {
            const now = Date.now();
            const fireRate = getFireRate();
            
            if (now - gameState.lastAttackTime < fireRate) return;
            
            // Check if burst mode is active
            const isBurst = gameState.abilities.burst.active;
            const shotCount = isBurst ? 3 : 1;
            
            for (let s = 0; s < shotCount; s++) {
                setTimeout(() => {
                    createProjectile();
                }, s * 50);
            }
            
            gameState.lastAttackTime = now;
        }

        function createProjectile(angle = null, isMega = false) {
            const texture = isMega ? megaBallTexture : projectileTexture;
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const sprite = new THREE.Sprite(material);
            const scale = isMega ? 3 : 1.5;
            sprite.scale.set(scale, scale, 1);
            sprite.position.copy(gameState.player.position);
            sprite.position.y = 1.5;
            
            const shootAngle = angle !== null ? angle : -gameState.player.rotation;
            const direction = new THREE.Vector3(
                Math.sin(shootAngle),
                0,
                Math.cos(shootAngle)
            );
            
            const damage = getProjectileDamage() * (isMega ? 5 : 1);
            
            const projectile = {
                sprite,
                direction,
                speed: isMega ? 0.3 : CONFIG.projectileSpeed,
                damage,
                life: isMega ? 180 : CONFIG.projectileLife,
                isMega,
                piercing: isMega
            };
            
            scene.add(sprite);
            gameState.projectiles.push(projectile);
        }

        function updateProjectiles() {
            const aimAssistStrength = gameState.upgrades.aimAssist.level * 0.08;
            
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                // Apply aim assist (curve toward nearest enemy)
                if (aimAssistStrength > 0 && !proj.isMega) {
                    let nearestEnemy = null;
                    let nearestDist = 15;
                    
                    for (const enemy of gameState.enemies) {
                        const dx = enemy.sprite.position.x - proj.sprite.position.x;
                        const dz = enemy.sprite.position.z - proj.sprite.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    }
                    
                    if (nearestEnemy) {
                        const targetDir = new THREE.Vector3(
                            nearestEnemy.sprite.position.x - proj.sprite.position.x,
                            0,
                            nearestEnemy.sprite.position.z - proj.sprite.position.z
                        ).normalize();
                        
                        proj.direction.lerp(targetDir, aimAssistStrength);
                        proj.direction.normalize();
                    }
                }
                
                // Move projectile
                proj.sprite.position.x += proj.direction.x * proj.speed;
                proj.sprite.position.z += proj.direction.z * proj.speed;
                proj.life--;
                
                // Check enemy collisions
                let hitSomething = false;
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = proj.sprite.position.x - enemy.sprite.position.x;
                    const dz = proj.sprite.position.z - enemy.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 1.5) {
                        enemy.health -= proj.damage;
                        enemy.hitFlash = 10;
                        
                        if (!proj.piercing) {
                            hitSomething = true;
                            break;
                        }
                    }
                }
                
                // Check boss collisions
                for (const boss of gameState.bosses) {
                    const dx = proj.sprite.position.x - boss.sprite.position.x;
                    const dz = proj.sprite.position.z - boss.sprite.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < 4) {
                        boss.health -= proj.damage;
                        boss.hitFlash = 10;
                        if (!proj.piercing) {
                            hitSomething = true;
                        }
                    }
                }
                
                if (hitSomething || proj.life <= 0) {
                    scene.remove(proj.sprite);
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        // ============================================
        // ABILITIES
        // ============================================
        function useSpreadAbility() {
            if (gameState.abilities.spread.cooldown > 0) return;
            
            // Fire 5 projectiles in 90¬∞ arc
            const baseAngle = -gameState.player.rotation;
            const spreadAngle = Math.PI / 2; // 90 degrees
            
            for (let i = 0; i < 5; i++) {
                const angle = baseAngle - spreadAngle / 2 + (spreadAngle / 4) * i;
                createProjectile(angle, false);
            }
            
            const cooldown = CONFIG.spreadCooldown - (gameState.upgrades.spreadCooldown.level * 600);
            gameState.abilities.spread.cooldown = cooldown;
            gameState.abilities.spread.maxCooldown = cooldown;
        }

        function useBurstAbility() {
            if (gameState.abilities.burst.cooldown > 0) return;
            
            gameState.abilities.burst.active = true;
            const duration = CONFIG.burstDuration + (gameState.upgrades.burstDuration.level * 500);
            gameState.abilities.burst.duration = duration;
            
            setTimeout(() => {
                gameState.abilities.burst.active = false;
            }, duration);
            
            gameState.abilities.burst.cooldown = CONFIG.burstCooldown;
            gameState.abilities.burst.maxCooldown = CONFIG.burstCooldown;
        }

        function useMegaAbility() {
            if (gameState.abilities.mega.cooldown > 0) return;
            
            createProjectile(null, true);
            
            gameState.abilities.mega.cooldown = CONFIG.megaCooldown;
            gameState.abilities.mega.maxCooldown = CONFIG.megaCooldown;
        }

        function updateAbilityCooldowns(delta) {
            // Update spread cooldown
            if (gameState.abilities.spread.cooldown > 0) {
                gameState.abilities.spread.cooldown -= delta;
            }
            
            // Update burst cooldown
            if (gameState.abilities.burst.cooldown > 0) {
                gameState.abilities.burst.cooldown -= delta;
            }
            
            // Update mega cooldown
            if (gameState.abilities.mega.cooldown > 0) {
                gameState.abilities.mega.cooldown -= delta;
            }
            
            // Update UI
            updateAbilityUI();
        }

        function updateAbilityUI() {
            // Spread
            const spreadPct = gameState.abilities.spread.cooldown / gameState.abilities.spread.maxCooldown;
            document.getElementById('spreadCooldown').style.height = (spreadPct * 100) + '%';
            document.getElementById('spreadBtn').classList.toggle('on-cooldown', spreadPct > 0);
            
            // Burst
            const burstPct = gameState.abilities.burst.cooldown / gameState.abilities.burst.maxCooldown;
            document.getElementById('burstCooldown').style.height = (burstPct * 100) + '%';
            document.getElementById('burstBtn').classList.toggle('on-cooldown', burstPct > 0);
            
            // Mega
            const megaPct = gameState.abilities.mega.cooldown / gameState.abilities.mega.maxCooldown;
            document.getElementById('megaCooldown').style.height = (megaPct * 100) + '%';
            document.getElementById('megaBtn').classList.toggle('on-cooldown', megaPct > 0);
        }

        // ============================================
        // XP & LEVELING
        // ============================================
        function spawnXPOrb(position, amount) {
            const material = new THREE.SpriteMaterial({ 
                map: xpOrbTexture, 
                transparent: true 
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1, 1, 1);
            sprite.position.copy(position);
            sprite.position.y = 0.5;
            
            const orb = {
                sprite,
                amount,
                bobOffset: Math.random() * Math.PI * 2
            };
            
            scene.add(sprite);
            gameState.xpOrbs.push(orb);
        }

        function updateXPOrbs() {
            const time = Date.now() * 0.003;
            
            for (let i = gameState.xpOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.xpOrbs[i];
                
                // Bob animation
                orb.sprite.position.y = 0.5 + Math.sin(time + orb.bobOffset) * 0.2;
                
                // Check pickup
                const dx = gameState.player.position.x - orb.sprite.position.x;
                const dz = gameState.player.position.z - orb.sprite.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                // Magnet pull
                if (dist < 5) {
                    orb.sprite.position.x += (dx / dist) * 0.1;
                    orb.sprite.position.z += (dz / dist) * 0.1;
                }
                
                if (dist < 1.5) {
                    gainXP(orb.amount);
                    scene.remove(orb.sprite);
                    gameState.xpOrbs.splice(i, 1);
                }
            }
        }

        function gainXP(amount) {
            gameState.xp += amount;
            gameState.totalXPEarned += amount;
            updateXPUI();
        }

        // ============================================
        // PLAYER STATS CALCULATIONS
        // ============================================
        function getMaxHealth() {
            return CONFIG.playerMaxHealth + (gameState.upgrades.maxHealth.level * 20);
        }

        function getProjectileDamage() {
            return CONFIG.playerBaseDamage + (gameState.upgrades.baseDamage.level * 8);
        }

        function getFireRate() {
            // Returns ms between shots (lower = faster)
            const reduction = gameState.upgrades.fireRate.level * 150;
            return Math.max(CONFIG.playerBaseFireRate - reduction, 200);
        }

        // ============================================
        // DAMAGE & HEALTH
        // ============================================
        function takeDamage(amount) {
            gameState.player.health -= amount;
            
            // Flash effect
            const flash = document.getElementById('damageFlash');
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 100);
            
            updateHealthUI();
            
            if (gameState.player.health <= 0) {
                gameOver();
            }
        }

        function heal(amount) {
            gameState.player.health = Math.min(
                gameState.player.health + amount, 
                getMaxHealth()
            );
            updateHealthUI();
        }

        // ============================================
        // UI UPDATES
        // ============================================
        function updateHealthUI() {
            const maxHP = getMaxHealth();
            const pct = (gameState.player.health / maxHP) * 100;
            document.getElementById('healthFill').style.width = pct + '%';
            document.getElementById('healthText').textContent = 
                Math.ceil(gameState.player.health) + '/' + maxHP;
        }

        function updateXPUI() {
            document.getElementById('xpText').textContent = gameState.xp;
            // Could add progress bar to next level threshold here
        }

        function updateFloorUI() {
            const floorText = gameState.currentFloor === 0 ? 'TOWN' : 'FLOOR ' + gameState.currentFloor;
            document.querySelector('.floor-info').textContent = floorText;
        }

        function updateRoomUI() {
            const roomNames = {
                center: 'CENTER HALL',
                north: 'NORTH CHAMBER',
                south: 'SOUTH CHAMBER',
                east: 'EAST CHAMBER',
                west: 'WEST CHAMBER'
            };
            document.getElementById('roomIndicator').textContent = 
                roomNames[gameState.currentRoom] || 'UNKNOWN';
        }

        // ============================================
        // UPGRADE SYSTEM
        // ============================================
        function getUpgradeCost(upgradeName) {
            const upgrade = gameState.upgrades[upgradeName];
            return Math.floor(upgrade.baseCost * Math.pow(upgrade.costMult, upgrade.level));
        }

        function purchaseUpgrade(upgradeName) {
            const upgrade = gameState.upgrades[upgradeName];
            const cost = getUpgradeCost(upgradeName);
            
            if (gameState.xp >= cost && upgrade.level < upgrade.maxLevel) {
                gameState.xp -= cost;
                upgrade.level++;
                
                // Apply upgrade effects
                if (upgradeName === 'maxHealth') {
                    gameState.player.maxHealth = getMaxHealth();
                    gameState.player.health = Math.min(
                        gameState.player.health + 20, 
                        gameState.player.maxHealth
                    );
                }
                
                updateUpgradeMenu();
                updateHealthUI();
                updateXPUI();
            }
        }

        function updateUpgradeMenu() {
            document.querySelectorAll('.upgrade-item').forEach(item => {
                const upgradeName = item.dataset.upgrade;
                if (!upgradeName || !gameState.upgrades[upgradeName]) return;
                
                const upgrade = gameState.upgrades[upgradeName];
                const cost = getUpgradeCost(upgradeName);
                const isMaxed = upgrade.level >= upgrade.maxLevel;
                
                item.querySelector('.upgrade-level span').textContent = upgrade.level;
                
                const btn = item.querySelector('.upgrade-btn');
                if (isMaxed) {
                    btn.textContent = 'MAX';
                    btn.disabled = true;
                    item.classList.add('maxed');
                } else {
                    btn.textContent = cost + ' XP';
                    btn.disabled = gameState.xp < cost;
                    item.classList.remove('maxed');
                }
            });
        }

        // ============================================
        // MENU CONTROLS
        // ============================================
        function openMenu() {
            gameState.menuOpen = true;
            document.getElementById('upgradeMenu').style.display = 'flex';
            updateUpgradeMenu();
        }

        function closeMenu() {
            gameState.menuOpen = false;
            document.getElementById('upgradeMenu').style.display = 'none';
        }

        // ============================================
        // DIALOGUE SYSTEM
        // ============================================
        function showDialogue(speaker, text, callback = null) {
            gameState.dialogueActive = true;
            document.getElementById('dialogueSpeaker').textContent = speaker;
            document.getElementById('dialogueText').textContent = text;
            document.getElementById('dialogueBox').classList.add('active');
            
            gameState.dialogueCallback = callback;
        }

        function closeDialogue() {
            document.getElementById('dialogueBox').classList.remove('active');
            gameState.dialogueActive = false;
            
            if (gameState.dialogueCallback) {
                gameState.dialogueCallback();
                gameState.dialogueCallback = null;
            }
        }

        // ============================================
        // GAME OVER
        // ============================================
        function gameOver() {
            gameState.currentState = GAME_STATE.GAME_OVER;
            
            document.getElementById('finalFloor').textContent = gameState.maxFloorReached;
            document.getElementById('finalKills').textContent = gameState.kills;
            document.getElementById('finalXP').textContent = gameState.totalXPEarned;
            document.getElementById('gameOver').style.display = 'flex';
        }

        function restartGame() {
            // Return to town with current progress
            document.getElementById('gameOver').style.display = 'none';
            
            // Reset health
            gameState.player.health = getMaxHealth();
            updateHealthUI();
            
            // Clear enemies
            gameState.enemies.forEach(e => scene.remove(e.sprite));
            gameState.enemies = [];
            
            // Clear projectiles
            gameState.projectiles.forEach(p => scene.remove(p.sprite));
            gameState.projectiles = [];
            
            // Clear XP orbs
            gameState.xpOrbs.forEach(o => scene.remove(o.sprite));
            gameState.xpOrbs = [];
            
            // Return to town
            enterTown();
        }

        // ============================================
        // SCENE MANAGEMENT
        // ============================================
        function enterTown() {
            gameState.currentState = GAME_STATE.TOWN;
            gameState.currentFloor = 0;
            
            // Position player in town
            gameState.player.position.set(0, 0, 0);
            playerGroup.position.copy(gameState.player.position);
            
            // Update lighting for town (warmer)
            scene.fog = new THREE.FogExp2(0x1a2a1a, 0.03);
            
            updateFloorUI();
            
            // Show welcome dialogue if first time
            showDialogue('THE GUIDE', 
                'Welcome, traveler. The Obelisk awaits. Approach the entrance when you are ready to descend.');
        }

        function enterDungeon(floor) {
            gameState.currentState = GAME_STATE.DUNGEON;
            gameState.currentFloor = floor;
            gameState.currentRoom = 'center';
            gameState.maxFloorReached = Math.max(gameState.maxFloorReached, floor);
            
            // Update fog based on floor theme
            const themeColors = getFloorThemeColors(floor);
            scene.fog = new THREE.FogExp2(themeColors.fog, CONFIG.fogDensity);
            
            // Clear old rooms
            gameState.rooms.forEach(room => scene.remove(room));
            gameState.rooms.clear();
            gameState.visitedRooms.clear();
            gameState.clearedRooms.clear();
            
            // Create dungeon rooms
            Object.keys(roomLayout).forEach(roomId => {
                createRoom(roomId, floor);
            });
            
            // Position player in center
            gameState.player.position.set(0, 0, 0);
            playerGroup.position.copy(gameState.player.position);
            
            // Spawn enemies in center room
            spawnRoomEnemies('center', floor);
            gameState.visitedRooms.add('center');
            
            updateFloorUI();
            updateRoomUI();
        }

        // ============================================
        // SAVE SYSTEM
        // ============================================
        function saveGame() {
            const saveData = {
                version: 1,
                player: {
                    maxFloorReached: gameState.maxFloorReached,
                    currentXP: gameState.xp,
                    totalXPEarned: gameState.totalXPEarned,
                    kills: gameState.kills,
                    upgrades: {}
                },
                timestamp: Date.now()
            };
            
            // Copy upgrade levels
            Object.keys(gameState.upgrades).forEach(key => {
                saveData.player.upgrades[key] = gameState.upgrades[key].level;
            });
            
            localStorage.setItem('obelisk_save', JSON.stringify(saveData));
        }

        function loadGame() {
            const data = localStorage.getItem('obelisk_save');
            if (!data) return false;
            
            try {
                const saveData = JSON.parse(data);
                
                gameState.maxFloorReached = saveData.player.maxFloorReached || 1;
                gameState.xp = saveData.player.currentXP || 0;
                gameState.totalXPEarned = saveData.player.totalXPEarned || 0;
                gameState.kills = saveData.player.kills || 0;
                
                // Restore upgrades
                if (saveData.player.upgrades) {
                    Object.keys(saveData.player.upgrades).forEach(key => {
                        if (gameState.upgrades[key]) {
                            gameState.upgrades[key].level = saveData.player.upgrades[key];
                        }
                    });
                }
                
                // Apply upgrade effects
                gameState.player.maxHealth = getMaxHealth();
                gameState.player.health = gameState.player.maxHealth;
                
                return true;
            } catch (e) {
                console.error('Failed to load save:', e);
                return false;
            }
        }

        // Auto-save on page unload
        window.addEventListener('beforeunload', saveGame);

        // ============================================
        // INPUT HANDLING
        // ============================================
        
        // Joystick setup
        const joystickArea = document.getElementById('joystickArea');
        const joystickThumb = document.getElementById('joystickThumb');
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;

        joystickArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystickArea.getBoundingClientRect();
            joystickStartX = touch.clientX - rect.left;
            joystickStartY = touch.clientY - rect.top;
            joystickActive = true;
        });

        joystickArea.addEventListener('touchmove', (e) => {
            if (!joystickActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = joystickArea.getBoundingClientRect();
            let dx = (touch.clientX - rect.left) - 75; // Center of joystick
            let dz = (touch.clientY - rect.top) - 75;
            
            // Clamp to max radius
            const dist = Math.sqrt(dx * dx + dz * dz);
            const maxDist = 50;
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dz = (dz / dist) * maxDist;
            }
            
            // Update thumb position
            joystickThumb.style.left = (50 + dx) + 'px';
            joystickThumb.style.top = (50 + dz) + 'px';
            
            // Update controls
            controls.moveX = dx / maxDist;
            controls.moveZ = dz / maxDist;
        });

        joystickArea.addEventListener('touchend', () => {
            joystickActive = false;
            joystickThumb.style.left = '50px';
            joystickThumb.style.top = '50px';
            controls.moveX = 0;
            controls.moveZ = 0;
        });

        // View area for camera rotation
        const viewArea = document.getElementById('viewArea');
        let isDragging = false;
        let touchStartX = 0;

        viewArea.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                isDragging = true;
            }
        });

        viewArea.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1 && !gameState.dialogueActive) {
                const dx = e.touches[0].clientX - touchStartX;
                gameState.player.rotation += dx * 0.005;
                touchStartX = e.touches[0].clientX;
            }
        });

        viewArea.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Mouse support for desktop
        viewArea.addEventListener('mousedown', (e) => {
            touchStartX = e.clientX;
            isDragging = true;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && !gameState.dialogueActive) {
                const dx = e.clientX - touchStartX;
                gameState.player.rotation += dx * 0.005;
                touchStartX = e.clientX;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Action buttons
        document.getElementById('attackBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.dialogueActive) shootProjectile();
        });

        document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.dialogueActive && gameState.player.isGrounded) {
                gameState.player.velocity.y = CONFIG.playerJumpForce;
                gameState.player.isGrounded = false;
            }
        });

        // Ability buttons
        document.getElementById('spreadBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.dialogueActive) useSpreadAbility();
        });

        document.getElementById('burstBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.dialogueActive) useBurstAbility();
        });

        document.getElementById('megaBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.dialogueActive) useMegaAbility();
        });

        // Menu button
        document.getElementById('menuBtn').addEventListener('click', () => {
            if (gameState.menuOpen) closeMenu();
            else openMenu();
        });

        // Close menu button
        document.getElementById('closeMenu').addEventListener('click', closeMenu);

        // Upgrade buttons
        document.querySelectorAll('.upgrade-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const upgradeName = btn.parentElement.dataset.upgrade;
                if (upgradeName) purchaseUpgrade(upgradeName);
            });
        });

        // Dialogue continue button
        document.getElementById('dialogueContinue').addEventListener('click', closeDialogue);

        // Restart button
        document.getElementById('restartBtn').addEventListener('click', restartGame);

        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (gameState.menuOpen) {
                if (e.key === 'Escape') closeMenu();
                return;
            }
            if (gameState.dialogueActive) {
                if (e.key === ' ' || e.key === 'Enter') closeDialogue();
                return;
            }
            
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': controls.moveZ = -1; break;
                case 's': case 'arrowdown': controls.moveZ = 1; break;
                case 'a': case 'arrowleft': controls.moveX = -1; break;
                case 'd': case 'arrowright': controls.moveX = 1; break;
                case ' ': shootProjectile(); break;
                case 'q': useSpreadAbility(); break;
                case 'e': useBurstAbility(); break;
                case 'r': useMegaAbility(); break;
                case 'escape': 
                    if (gameState.menuOpen) closeMenu();
                    else openMenu();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': if (controls.moveZ < 0) controls.moveZ = 0; break;
                case 's': case 'arrowdown': if (controls.moveZ > 0) controls.moveZ = 0; break;
                case 'a': case 'arrowleft': if (controls.moveX < 0) controls.moveX = 0; break;
                case 'd': case 'arrowright': if (controls.moveX > 0) controls.moveX = 0; break;
            }
        });

        // ============================================
        // PLAYER UPDATE
        // ============================================
        function updatePlayer() {
            if (gameState.currentState === GAME_STATE.GAME_OVER) return;
            if (gameState.dialogueActive) return;
            
            const moveSpeed = CONFIG.playerSpeed;
            
            // Calculate movement direction based on camera orientation
            const moveAngle = gameState.player.rotation;
            
            if (controls.moveX !== 0 || controls.moveZ !== 0) {
                // Forward/backward
                gameState.player.position.x -= Math.sin(moveAngle) * controls.moveZ * moveSpeed;
                gameState.player.position.z -= Math.cos(moveAngle) * controls.moveZ * moveSpeed;
                
                // Strafe left/right
                gameState.player.position.x -= Math.cos(moveAngle) * controls.moveX * moveSpeed;
                gameState.player.position.z += Math.sin(moveAngle) * controls.moveX * moveSpeed;
            }
            
            // Apply gravity and jumping
            if (!gameState.player.isGrounded) {
                gameState.player.velocity.y -= 0.01; // Gravity
                gameState.player.position.y += gameState.player.velocity.y;
                
                if (gameState.player.position.y <= 0) {
                    gameState.player.position.y = 0;
                    gameState.player.velocity.y = 0;
                    gameState.player.isGrounded = true;
                }
            }
            
            // Update visual position
            playerGroup.position.copy(gameState.player.position);
            
            // Update camera
            const camDist = 12 * gameState.cameraZoom;
            const camHeight = 8 * gameState.cameraZoom;
            camera.position.x = gameState.player.position.x + Math.sin(gameState.player.rotation) * camDist;
            camera.position.z = gameState.player.position.z + Math.cos(gameState.player.rotation) * camDist;
            camera.position.y = gameState.player.position.y + camHeight;
            camera.lookAt(
                gameState.player.position.x,
                gameState.player.position.y + 2,
                gameState.player.position.z
            );
            
            // Update ground to follow player
            ground.position.x = gameState.player.position.x;
            ground.position.z = gameState.player.position.z;
            
            // Check room transitions
            checkRoomTransition();
        }

        function checkRoomTransition() {
            // Simple room detection based on player position
            const px = gameState.player.position.x;
            const pz = gameState.player.position.z;
            const halfRoom = CONFIG.roomSize / 2;
            
            let newRoom = 'center';
            
            // Check if in outer rooms
            if (pz < -halfRoom - 5) {
                newRoom = 'north';
            } else if (pz > halfRoom + 5) {
                newRoom = 'south';
            } else if (px > halfRoom + 5) {
                newRoom = 'east';
            } else if (px < -halfRoom - 5) {
                newRoom = 'west';
            }
            
            if (newRoom !== gameState.currentRoom) {
                gameState.currentRoom = newRoom;
                updateRoomUI();
                
                // Spawn enemies if room not visited
                if (!gameState.visitedRooms.has(newRoom)) {
                    gameState.visitedRooms.add(newRoom);
                    if (gameState.currentFloor > 0) {
                        spawnRoomEnemies(newRoom, gameState.currentFloor);
                    }
                }
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        let lastTime = 0;

        function animate(time) {
            requestAnimationFrame(animate);
            
            const delta = time - lastTime;
            lastTime = time;
            
            if (gameState.currentState !== GAME_STATE.GAME_OVER && !gameState.menuOpen) {
                updatePlayer();
                updateEnemies();
                updateProjectiles();
                updateXPOrbs();
                updateAbilityCooldowns(delta);
            }
            
            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            // Try to load saved game
            loadGame();
            
            // Update UI
            updateHealthUI();
            updateXPUI();
            updateUpgradeMenu();
            
            // Start in town
            enterTown();
            
            // For testing - uncomment to start directly in dungeon
            // enterDungeon(1);
            
            // Start game loop
            requestAnimationFrame(animate);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start game
        init();
    </script>
</body>
</html>
